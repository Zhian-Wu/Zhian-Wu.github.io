<!-- build time:Fri Mar 07 2025 16:46:51 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://zhian-wu.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://zhian-wu.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://zhian-wu.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="计算机网络"><link rel="canonical" href="https://zhian-wu.github.io/cs/job/Bagu/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><title>计算机网络 - 八股文 - 找工作 - 计算机科学 | Zhian's Blog =</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">计算机网络</h1><div class="meta"><span class="item" title="创建时间：2021-09-16 15:57:37"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-09-16T15:57:37+08:00">2021-09-16</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Zhian's Blog</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeyvx1d4j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeuv80yoj20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipey84bjtj20zk0m8hdt.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cs/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cs/job/" itemprop="item" rel="index" title="分类于 找工作"><span itemprop="name">找工作</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cs/job/Bagu/" itemprop="item" rel="index" title="分类于 八股文"><span itemprop="name">八股文</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://zhian-wu.github.io/cs/job/Bagu/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Wu Zhian"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><h2 id="q计算机网络分哪几层"><a class="anchor" href="#q计算机网络分哪几层">#</a> Q：计算机网络分哪几层？</h2><ul><li>OSI 七层模型<ol><li><p>应用层</p><p>主要为用户提供应用服务，<strong>应用层工作在用户态，传输层以下工作在内核态</strong></p><p>主要协议：http,dns,smtp (邮件协议）,ftp,ssh,Telnet (远程登录协议）</p><p>Telnet (远程登录协议）：通过一个终端登录到其他服务器，明文传输，安全风险</p></li><li><p>表示层</p><p>主要负责进行数据格式的转换，加密解密；协议示例：JPEG、MPEG</p></li><li><p>会话层</p><p>对会话的管理，协议 SSH、TLS。</p></li><li><p>传输层</p><p>提供端到端的服务，也就是为两台主机进程之间提供服务</p><p>主要协议：TCP UDP</p></li><li><p>网络层</p><p>提供路由和寻址的功能， 决定数据在网络中的走向</p><p>主要协议：ip</p></li><li><p>链路层</p><p>帧编码，差错纠正</p></li><li><p>物理层</p><p>比特流的传输</p></li></ol></li><li>如果是 TCP/IP，则分为四层<ol><li>应用层</li><li>传出层</li><li>网络层</li><li>网络接口层</li></ol></li></ul><h2 id="q为什么要分层"><a class="anchor" href="#q为什么要分层">#</a> Q：为什么要分层？</h2><ul><li>各层之间相互独立，彼此不需要关心对方是怎么实现的，只要调用相关接口就行</li><li>更加的灵活，修改某一层的功能不会影响其他层</li><li>分层可以帮助我们将大的问题化解成每层的小问题来解决</li></ul><h2 id="q为什么现在都用四层而不是七层模型"><a class="anchor" href="#q为什么现在都用四层而不是七层模型">#</a> Q：为什么现在都用四层而不是七层模型？</h2><p>四层模型更加的简单和实用，七层模型存在于理论，实现起来更加复杂。所以实际中使用的都是四层模型</p><h2 id="qip地址分成几个部分"><a class="anchor" href="#qip地址分成几个部分">#</a> Q：IP 地址分成几个部分？</h2><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；</li><li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</li></ul><h2 id="q字网掩码有什么用"><a class="anchor" href="#q字网掩码有什么用">#</a> Q：字网掩码有什么用？</h2><p>子网掩码可以根据 IP 地址 得到网络号和主机号。</p><p>子网掩码和 IP 按位与运算得到网络号</p><p>子网掩码取反和 IP 按位与运算得到主机号</p><h2 id="q从输入url到网页显示的过程是怎样的"><a class="anchor" href="#q从输入url到网页显示的过程是怎样的">#</a> Q：从输入 URL 到网页显示的过程是怎样的？</h2><ol><li><p>首先会对 URL 进行解析，URL 可分为协议、域名、端口、资源路径几个部分。</p></li><li><p>浏览器是不能根据 URL 知道服务器的 IP 地址的。这时需要用到 DNS 协议。它是应用层的协议，它会割据域名解析出 IP 地址</p><p>DNS 解析域名的过程：</p><ul><li>首先访问本地域名服务器，本地域名服务器会查缓存有没有，有就直接返回，没有就会把这个请求发送给根域名服务器</li><li>根域名服务器会告诉本地域名服务器去哪个顶级域名服务器查</li><li>于是本地域名服务器会将发请求给顶级域名服务器，顶级域名服务器会告诉它去哪个权威域名服务器查</li><li>最终本地域名服务器向权威域名服务器发送请求，权威域名服务器将查到的 IP 地址返回给本地域名服务器</li><li>本地域名服务器将 IP 地址返回给浏览器，并存入到缓存中</li></ul></li><li><p>经过三次握手建立 TCP 连接，将 HTTP 请求加上 TCP 首部组装成 TCP 报文</p></li><li><p>把 TCP 报文加上 IP 的首部变成 IP 数据报，IP 的首部里面会有源 IP 地址和目的 IP 地址， 然后就可以根据目的 IP 地址匹配合适的发送端口。</p></li><li><p>把 IP 数据报加上 MAC 首部变成 MAC 包，MAC 首部里有源 MAC 地址和目的 MAC 地址，如果找不到目的 MAC 地址，就要通过 ARP 协议来获取<br>然后就能通过网卡把这个数据包发出去了。</p></li><li><p>数据包在同一网络内会经过交换机进行转发，跨网段的时候会经过路由器进行转发，最终到达目的主机。如果有配置 NAT 的话，出自己的网段和进入目的主机的网段的过程中还会涉及 IP 地址的改变。</p></li><li><p>目的主机接收到数据包后，从下往上把数据包层层拆开获取 HTTP 请求，最后由服务器处理完请求后，将返回结果也这样层层封装然后按同样的流程再发回来。</p></li><li><p>当客户端浏览器接收到 HTTP 响应报文的时候，解析报文，渲染页面，同时如果还需要继续请求资源，就继续发请求直到把页面渲染完毕为止。</p></li></ol><h2 id="qip地址和mac地址的区别"><a class="anchor" href="#qip地址和mac地址的区别">#</a> Q：IP 地址和 MAC 地址的区别？</h2><ul><li>IP 地址是在网络层（OSI 模型中的第三层）使用的地址，用于在网络上唯一标识设备的位置。MAC 地址是在数据链路层（OSI 模型中的第二层）使用的地址，用于在局域网上唯一标识网络适配器。</li><li>IPv4 地址由 32 位二进制数表示（通常用点分十进制表示），IPv6 地址由 128 位二进制数表示。MAC 地址通常由 48 位二进制数表示</li><li>IP 地址通常由网络管理员或 Internet 服务提供商分配，根据需要分配给不同的设备。MAC 地址是设备出厂时固定的，由设备制造商分配。</li></ul><h2 id="qlinux是如何发数据包的"><a class="anchor" href="#qlinux是如何发数据包的">#</a> Q：Linux 是如何发数据包的？</h2><ol><li>应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中，内核会申请一个 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li><li>网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理</li><li>逐层添加 TCP 头部，IP 头部，帧头之后，加入到网卡的发送队列</li><li>触发中断告诉网卡驱动程序有数据要发送，然后触发数据发送</li></ol><h2 id="q发送数据包涉及几次复制"><a class="anchor" href="#q发送数据包涉及几次复制">#</a> Q：发送数据包涉及几次复制？</h2><p></p><p>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</p><p>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</p><h2 id="q什么是http"><a class="anchor" href="#q什么是http">#</a> Q：什么是 HTTP？</h2><p>HTTP 是超文本传输协议。</p><ul><li>协议：计算机之间交流通信的规范</li><li>传输：双向传输</li><li>超文本：<strong>超越了普通文本的文本</strong>，它是文字、图片、视频等的混合体</li></ul><h2 id="qhttp状态码有哪些"><a class="anchor" href="#qhttp状态码有哪些">#</a> Q：HTTP 状态码有哪些？</h2><ul><li><p>1××</p><p><strong>提示信息</strong>，协议处理的一种中间状态</p></li><li><p>2××</p><p>成功，报文收到并成功处理</p><ul><li><p>200 OK</p><p>一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</p></li><li><p>204 <strong>No Content</strong></p><p>与 200 OK 基本相同，但响应头没有 body 数据。</p></li><li><p>206 <strong>Partial Content</strong></p><p>应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据<strong>并不是资源的全部</strong>，而是其中的一部分，也是服务器处理成功的状态。</p></li></ul></li><li><p>3××</p><p>客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong></p><ul><li><p>301 <strong>Moved Permanently</strong></p><p>表示永久重定向，说明请求的<strong>资源已经不存在了</strong>，需改用新的 URL 再次访问。</p></li><li><p>302 Found</p><p>表示临时重定向，说明<strong>请求的资源还在</strong>，但暂时需要用另一个 URL 来访问。</p></li><li><p><strong>304 Not Modified</strong></p><p>不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称<strong>缓存重定向</strong>，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</p></li></ul></li><li><p>4××</p><p>客户端发送的<strong>报文有误</strong></p><ul><li><p>400 Bad Request</p><p>表示客户端请求的报文有错误，但只是个笼统的错误</p></li><li><p><strong>403 Forbidden</strong></p><p>表示服务器<strong>禁止访问资源</strong>，并不是客户端的请求出错</p></li><li><p><strong>404 Not Found</strong></p><p>表示请求的资源在服务器上不存在或未找到</p></li></ul></li><li><p>5××</p><p>客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong></p><ul><li><p>500 Internal Server Error</p><p>是个笼统通用的错误码</p></li><li><p>501 Not Implemented</p><p>表示客户端请求的功能还不支持</p></li><li><p><strong>502 Bad Gateway</strong></p><p>通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</p></li><li><p><strong>503 Service Unavailable</strong></p><p>表示服务器<strong>当前很忙</strong>，暂时无法响应客户端</p></li></ul></li></ul><h2 id="qhttp协议报文格式"><a class="anchor" href="#qhttp协议报文格式">#</a> Q：HTTP 协议报文格式？</h2><p><img data-src="image/image_Y9_3AY4mfw.png" alt=""></p><p><img data-src="image/image_YtePlXOfVX.png" alt=""></p><h2 id="qhttp请求头常见字段有哪写"><a class="anchor" href="#qhttp请求头常见字段有哪写">#</a> Q：HTTP 请求头常见字段有哪写？</h2><p><img data-src="image/image_rGA6EUBc37.png" alt=""></p><table><thead><tr><th>请求头字段名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>能够接受的回应内容类型（Content-Types）。</td><td>Accept: text/plain</td></tr><tr><td>Authorization</td><td>用于超文本传输协议的认证的认证信息</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=</td></tr><tr><td>Host</td><td>服务器的域名</td><td>Host: <span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmc6ODA=">en.wikipedia.org:80</span></td></tr><tr><td>Cookie</td><td></td><td></td></tr><tr><td>Connection</td><td>该浏览器想要优先使用的连接类型</td><td>Connection: keep-alive Connection: Upgrade</td></tr><tr><td>Content-Length</td><td>本次回应的数据长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Type</td><td>本次数据的格式</td><td>如 type/html</td></tr><tr><td>Cache-Control</td><td>缓存机制</td><td></td></tr></tbody></table><h2 id="qhttp如何解决粘包问题"><a class="anchor" href="#qhttp如何解决粘包问题">#</a> Q：HTTP 如何解决粘包问题？</h2><p>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决 “粘包” 的问题。</p><h2 id="qhttp缓存技术有哪些"><a class="anchor" href="#qhttp缓存技术有哪些">#</a> Q：HTTP 缓存技术有哪些？</h2><ul><li><p>强制缓存</p><p>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p><p>强制缓存是利用 Cache-Control ，用来表示资源在客户端缓存的有效期</p><p>基本过程：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li><li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li><li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li></ul></li><li><p>协商缓存</p><p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>。一般是返回 304</p><p>通过设置响应头中的 Last-Modified 或 ETag 字段</p></li></ul><p><strong>协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong>。</p><h2 id="qhttp和https的区别"><a class="anchor" href="#qhttp和https的区别">#</a> Q：HTTP 和 HTTPS 的区别？</h2><ul><li>默认端口不同，HTTP 是 80 端口，HTTPS 是 443 端口</li><li>HTTP 采用的是明文传输，不安全，HTTPS 是建立在 SSL/TLS 基础上的，会将传输的数据进行加密，更加安全</li><li>HTTP 建立连接更快，HTTPS 除了建立 TCP 连接外，还要建立 SSL/TLS 连接</li><li>前缀不同，一个 htts://, 一个 http:</li><li>https 需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><h2 id="qhttp10-和http11区别http11优点"><a class="anchor" href="#qhttp10-和http11区别http11优点">#</a> Q：HTTP/1.0 和 HTTP/1.1 区别？（HTTP/1.1 优点）？</h2><ul><li><p>HTTP/1.0 是短连接，HTTP/1.1 是长连接</p><p>长链接的好处：短连接没请求一个资源都需要重新建立 TCP 连接，耗时耗资源。而长连接建立之后，不需要重新建立 TCP 连接</p></li><li><p>HTTP/1.1 引入了更多的响应码</p></li><li><p>HTTP/1.1 允许用户只请求资源的某一部分，而不需要将资源全部发送给客户端。这归功于<strong>请求头中 range 字段</strong></p></li><li><p>HTTP/1.1 支持管道传输，一个请求发送之后，不需要等待收到请求响应，就可以发送下一个请求</p></li></ul><h2 id="qhttp11-和http20区别http20的优点http11的缺点"><a class="anchor" href="#qhttp11-和http20区别http20的优点http11的缺点">#</a> Q：HTTP/1.1 和 HTTP/2.0 区别？（HTTP/2.0 的优点，HTTP/1.1 的缺点）？</h2><ul><li>HTTP/1.1 的缺点<ul><li><p>队头阻塞的问题</p><p>当顺序发送请求时，如果其中一个请求的响应阻塞了，其他请求的响应也会跟着阻塞，导致客户端请求不到数据。<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong>。</p><p><strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong></p></li><li><p>请求只能从客户端开始，服务器只能被动</p></li><li><p>请求没有优先级的控制</p></li><li><p>请求头没有压缩，头部越大，延迟越高</p></li></ul></li><li>HTTP/2.0 优化<ul><li><p>头部压缩</p><p>使用了 HPACK 算法来压缩头部，维护一张头部表（客户端，服务端都有），每次只需发送头部对应的索引即可。</p></li><li><p>二进制传输</p><p>相比 HTTP/1.1 的纯文本传输，二进制传输对机器更加友好，拿到数据之后可以直接解析，加快了传输效率</p></li><li><p>并发传输</p><p>引出了 Stream 请求，一个 TCP 连接可以包含多个 Stream，通过 Stream ID 区分不同的请求，并且服务端可以根据这个 ID 组装成完整的 HTTP 请求。所以发送端可以乱序的发送</p></li><li><p>服务器主动推送</p><p>服务器可以主动将相关资源主动推送给客户端</p><p>服务器使用的 stream id 是偶数（也不会问）</p><p>例子：在请求 html 页面，服务器会将相关的 css 也推送给客户端</p></li></ul></li></ul><h2 id="qhttp20-和http30区别http30的优点http20的缺点"><a class="anchor" href="#qhttp20-和http30区别http30的优点http20的缺点">#</a> Q：HTTP/2.0 和 HTTP/3.0 区别？（HTTP/3.0 的优点，HTTP/2.0 的缺点）？</h2><ul><li><p>HTTP/2.0 的缺点</p><p>它并没有完全解决队头阻塞问题。我们知道 http 是基于 tcp 的，tcp 是面向字节流的，tcp 必须保证收到的字节流完整有序才能将内核缓存中的数据返回给用户。假设其中有一段丢失了，那么其他的请求就必须等待这一段重传回来，应用层才能将数据拿出来。</p></li><li><p>HTTP/3.0 优化</p><p><strong>HTTP/3.0 是直接基于 UDP 的</strong>，UDP 是不管数据有没有有序，有没有出错，所以也就没有队头阻塞的问题</p><p>但 HTTP/3.0 采用 QUIC 保证数据的可靠</p><ul><li><p>保证数据的可靠性</p><p>HTTP/3.0 也有 stream，但其中某一部分数据丢失了，并不会阻塞其他的 stream。并且会触发重传机制，快速的重发丢失的数据</p></li><li><p>更快的连接</p><p>HTTP/2.0 建立连接需要先 tcp 握手，然后再 ssl/tls 握手。而 QUIC 其中包含了 TLS, 只需花费一个 RTT 就可以建立连接，用来确定连接 ID。并且在第二次连接时，可以将数据包和 QUIC 握手信息一起发送，达到 0RTT</p></li><li><p>连接迁移</p><p>当我们从移动网络切换到 WIFI 时，由于 ip 地址变了，需要重新建立连接，那么经过 TCP，TLS 握手后，时间是有点长的，迁移成本是比较高的</p><p>而 QUIC 是根据连接 ID 确认彼此连接的，当网络发生变化后，只要保留了上下文，就可以复用原连接，实现无延迟的连接迁移</p></li></ul></li></ul><h2 id="q如何对http11优化"><a class="anchor" href="#q如何对http11优化">#</a> Q：如何对 HTTP/1.1 优化？</h2><ul><li><p>尽量避免发送 HTTP 请求；</p><p>使用缓存减少重复的请求；客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系</p><p>万一缓存的响应不是最新的，而客户端并不知情，那么该怎么办呢？</p><p>服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。</p><p>假设服务器上的资源并没有变更，还要在服务器的响应带上这个资源吗？</p><p>只需要客户端在重新发送请求时，在请求的 <code>Etag</code> 头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个比较。</p><p>如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。</p><p>如果相同，说明客户端的缓存还是可以继续使用的，那么服务器<strong>仅返回不含有包体的 <strong><strong><code>304 Not Modified</code> </strong></strong>响应</strong>，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时</p></li><li><p>减少 HTTP 请求次数</p><ul><li><p>减少重定向次数</p><p>服务器上的一个资源可能由于迁移、维护等原因从 url1 移至 url2 后，而客户端不知情，它还是继续请求 url1，服务器通过 <code>302</code> 响应码和 <code>Location</code> 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。</p><p>那么，如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每一次的 HTTP 请求都得经过网络，这无疑会越降低网络性能。</p><p>重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</p></li><li><p>合并请求</p><p>如果把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着<strong>减少了重复发送的 HTTP 头部</strong>。</p><p>但是这样的合并请求会带来新的问题，<strong>当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件</strong>，这显然带来了额外的网络消耗</p></li><li><p>延迟发送</p><p>当前不需要的资源，我们没必要也获取过来，于是可以通过「<strong>按需获取</strong>」的方式，来减少第一时间的 HTTP 请求次数。例如请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果</p></li></ul></li><li><p>减少 HTTP 响应的数据大小</p><p>无损压缩：无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码。例如 gzip</p><p>有损压缩：有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。例如 webp 格式</p></li></ul><h2 id="qhttps是怎么加密的"><a class="anchor" href="#qhttps是怎么加密的">#</a> Q：HTTPS 是怎么加密的？</h2><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式</p><ul><li>首先<strong>通信建立前</strong>采用非对称加密的方式<strong>交换共享秘钥</strong>，后续就不再使用非对称加密。</li><li>然后通信过程中<strong>全部使用共享密钥加密明文数据</strong>，因为共享密钥速度快。</li></ul><p>加密解决了数据被窃取的风险。</p><h2 id="q为什么通信前用非对称加密只用非对称加密行不行"><a class="anchor" href="#q为什么通信前用非对称加密只用非对称加密行不行">#</a> Q：为什么通信前用非对称加密？（只用非对称加密行不行？）</h2><p>对称加密<strong>只使用一个密钥（这个密钥不是某一方单独产生，而是通过协商得出的），运算速度快</strong>，密钥必须保密，<strong>无法做到安全的密钥交换。</strong></p><p>正因为密钥交换得不到保障，所以采用非对称加密来传输上文提到得共享密钥。</p><p>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，公钥加密的内容只有私钥才能解开。</p><h2 id="q非对称加密中客户端拿到的是公钥还是私钥"><a class="anchor" href="#q非对称加密中客户端拿到的是公钥还是私钥">#</a> Q：非对称加密中，客户端拿到的是公钥还是私钥？</h2><p>公钥</p><p>服务器在进行 HTTPS 握手时会向客户端发送服务器证书，其中包含服务器的公钥。客户端会使用该公钥来加密通信内容或共享密钥，并将加密后的数据发送给服务器。服务器收到客户端发来的加密数据后，使用自己的私钥来解密</p><h2 id="qhttps如何防止数据被篡改"><a class="anchor" href="#qhttps如何防止数据被篡改">#</a> Q：HTTPS 如何防止数据被篡改？</h2><p>摘要算法 + 数字签名。</p><p>假设 A 用户向 B 用户发送一份文件</p><ul><li><p>首先，文件经过单向散列函数的处理得到一份占 128 位的摘要（无论文件多大，经过单向散列函数的处理，生成的摘要都是 128 位），这份摘要相当于该文件的 &quot;指纹&quot;，能够唯一地识别文件。</p></li><li><p>随后，用户 A 使用自己地私钥对这份 128 位地摘要进行加密，得到一份加密地摘要。（<strong>这就是数字签名，它是对摘要就行加密，而不是文件</strong>）</p></li><li><p>然后，用户 A 把<strong>文件、加密的摘要和公钥</strong>打包一起发给用户 B。传输的过程中并没有对文件进行加密处理。</p></li><li><p>用户 B 将收到的文件经过单向散列函数处理得出一份 128 位摘要，这份摘要是通过收到的文件得到的，存在被更改的可能；使用 A 提供的公钥对收到的 &quot;<strong> 加密的摘要</strong> &quot; 进行解密得到另一份 128 位摘要，这份摘要是通过原始文件得到的，一般认为代表真正的文件；然后将<strong>两份摘要进行比较。</strong></p><p>扩展问题：<strong>加密的摘要</strong>会被篡改吗？</p><p>不会，这份<strong>加密的摘要</strong>是 A 用户私钥生成的，只有对应的公钥才能解开。如果其他用户用他的私钥生成了一份加密摘要给到 B 用户，B 用户用公钥是解不开的，也就得到了文件被篡改</p></li><li><p>如果两份摘要相等，说明文件经过用户 A 签名之后，在传输的过程中没有被更改；若不相等，说明文件在传输过程中被更改了，或者说已经不是原来的文件了，此时用户 A 的签名失效</p></li></ul><h2 id="q非对称加密的两种方式"><a class="anchor" href="#q非对称加密的两种方式">#</a> Q：非对称加密的两种方式？</h2><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</li><li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</li></ul><h2 id="q数字证书的作用公钥也被替换怎么办"><a class="anchor" href="#q数字证书的作用公钥也被替换怎么办">#</a> Q：数字证书的作用？（公钥也被替换怎么办？）</h2><p>新的问题诞生了：用户 A 使用数字签名时给用户 B 发送了一个数据包，数据包中包含了 A 的公钥、文件和加密的摘要。那么问题来了：用户 B 如何确定收到的公钥是用户 A 发送的，而不是他人冒充用户 A 发送的呢？简而言之，<strong>其他人用自己的私钥生成新的加密摘要，又把公钥替换成自己的公钥，B 用户难以相信消息的正确性了</strong></p><p>解决方案：<strong>数字证书</strong></p><ul><li><p>首先，用户 A 向证书颁发机构提交个人信息，申请证书。通过 CA (认证中心）审核后，<strong>CA 生成用户 A 的证书，证书中包括了 A 的公钥和私钥还有 CA 的数字签名（CA 的私钥生成的）</strong>。证书颁发机构 CA 本身拥有一对密钥，这是对 CA 所颁发的证书进行数字签名和保密的基础，绝不能泄露。</p></li><li><p>用户 A 收到的证书中包括了<strong>带有 CA 数字签名的，专属 A 公钥和私钥，CA 的数字签名确保了别人不能伪造用户 A 的公钥和私钥</strong>。</p></li><li><p>同时，用户 B 也必须信任给用户 A 颁发证书的第三方认证机构 CA，即<strong>用户 B 拥有 CA 颁发的 &quot;CA 公钥</strong> &quot;。</p></li><li><p>通信时，用户 A 向用户 B 发送的数据包中的 &quot;加密的摘要&quot; 上有用户 A 的数字签名，“A 公钥” 上有认证机构 CA 的数字签名。用户 B 收到数据包之后，先要验证收到的 “A 公钥” 是否来源合法。所以，<strong>用户 B 先使用证书颁发机构颁发的 &quot;CA 公钥&quot; 验证收到的 &quot;A 公钥&quot; 是否由同一认证机构颁发，是否在颁发之后更改过。</strong></p><p>验证通过后，用户 B 便相信收到的 &quot;A 公钥&quot; 确实来自真实的用户 A。随后再使用 &quot;A 公钥&quot; 对 &quot;加密的摘要&quot; 进行解密，进行上文提到的对比操作，以判断文件是否更改。</p></li></ul><p>证书的吊销：</p><p>当用户 A 遗失或泄露了 CA 颁发的证书后，为了避免他人使用该证书冒充用户 A，用户 A 向认证机构 CA &quot;挂失&quot; 该证书。于是认证机构 CA 把该证书放入该认证机构的证书吊销列表（CRL）中，并在网上公示。</p><p>用户 B 在收到用户 A 的公钥时，<strong>除了要验证该公钥是否位认证机构颁发的，还要登录认证机构的网站查看该公钥是否已被认证机构吊销变为无效证书。</strong></p><h2 id="qhttps-是如何建立连接的其间交互了什么"><a class="anchor" href="#qhttps-是如何建立连接的其间交互了什么">#</a> Q：HTTPS 是如何建立连接的？其间交互了什么？</h2><ul><li><p>首先进行 TCP 三次握手</p></li><li><p>然后进行 TLS 四次握手</p><p><em>1. ClientHello</em></p><p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（ <code>Client Random</code> ），后面用于生成「会话秘钥」条件之一。（会被服务端保留）</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em></p><p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code> 。服务器回应的内容有如下内容：</p><p>（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（ <code>Server Random</code> ），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><p><em>3. 客户端回应</em></p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>（1）一个随机数（ <code>pre-master key</code> ）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><p><em>4. 服务器的最后回应</em></p><p>服务器收到客户端的第三个随机数（ <code>pre-master key</code> ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p></li></ul><h2 id="qhttp进行tcp连接之后在什么情况下会中断"><a class="anchor" href="#qhttp进行tcp连接之后在什么情况下会中断">#</a> Q：HTTP 进行 TCP 连接之后，在什么情况下会中断</h2><ul><li>当服务端或者客户端执行 close 系统调用的时候，会发送 FIN 报文，就会进行四次挥手的过程</li><li>当发送方发送了数据之后，接收方超过一段时间没有响应 ACK 报文，发送方重传数据达到最大次数的时候，就会断开 TCP 连接</li><li>当 HTTP 长时间没有进行请求和响应的时候，超过一定的时间，就会释放连接</li></ul><h2 id="qtsl握手里面的哈希函数用来干什么"><a class="anchor" href="#qtsl握手里面的哈希函数用来干什么">#</a> Q：TSL 握手里面的哈希函数用来干什么？</h2><p>用来计算握手消息的摘要，确保消息的完整性</p><h2 id="qtsl握手的过程中怎么确定对方的身份"><a class="anchor" href="#qtsl握手的过程中怎么确定对方的身份">#</a> Q：TSL 握手的过程中怎么确定对方的身份</h2><p>在 TLS 握手过程中，确定对方身份的主要方式是通过<strong>数字证书</strong>。服务器会向客户端发送包含自己公钥的数字证书，客户端通过验证数字证书的有效性、颁发者和域名等信息来确认服务器身份。另外，TLS 握手还包括双方的随机数生成、密钥协商等步骤来确保通信安全并确认双方的身份。</p><h2 id="qrsa算法的缺陷"><a class="anchor" href="#qrsa算法的缺陷">#</a> Q：RSA 算法的缺陷？</h2><p>因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解</p><h2 id="qrsa-和-ecdhe-握手过程的区别"><a class="anchor" href="#qrsa-和-ecdhe-握手过程的区别">#</a> Q：RSA 和 ECDHE 握手过程的区别？</h2><ul><li>RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密；（生成一个临时的椭圆曲线密钥对）</li><li>使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间（这个是 RFC 文档规定的，具体原因文档没有说明，所以这点我也不太明白）；</li><li>使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息；</li></ul><h2 id="q客户端校验数字证书的流程是怎样的"><a class="anchor" href="#q客户端校验数字证书的流程是怎样的">#</a> Q：客户端校验数字证书的流程是怎样的？</h2><p>CA 签发证书的过程</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程，：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><h2 id="q证书信任链是什么为什么要有"><a class="anchor" href="#q证书信任链是什么为什么要有">#</a> Q：证书信任链是什么？为什么要有？</h2><p>如果服务器提供的证书不是根证书，客户端会继续寻找证书链中的下一个证书，并检查该证书的签发者信息。客户端会重复这个过程，直到找到根证书。如果整个证书链都通过了验证，客户端将信任根证书，并信任由根证书签发的服务器证书。</p><p><strong>这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</strong></p><h2 id="qocsp的作用"><a class="anchor" href="#qocsp的作用">#</a> Q：OCSP 的作用？</h2><p>客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。这个访问过程是 HTTP 访问，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。</p><p><strong>CRL</strong> 称为证书吊销列表（<em>Certificate Revocation List</em>），这个列表是由 CA 定期更新，列表内容都是被撤销信任的证书序号，如果服务器的证书在此列表，就认为证书已经失效，不在的话，则认为证书是有效的。</p><p>但是 CRL 存在两个问题：</p><ul><li>第一个问题，由于 CRL 列表是由 CA 维护的，定期更新，如果一个证书刚被吊销后，客户端在更新 CRL 之前还是会信任这个证书，<strong>实时性较差</strong>；</li><li>第二个问题，<strong>随着吊销证书的增多，列表会越来越大，下载的速度就会越慢</strong>，下载完客户端还得遍历这么大的列表，那么就会导致客户端在校验证书这一环节的延时很大，进而拖慢了 HTTPS 连接。</li></ul><p>因此，现在基本都是使用 ** OCSP** ，名为在线证书状态协议（<em>Online Certificate Status Protocol</em>）来查询证书的有效性，它的工作方式是<strong>向 CA 发送查询请求，让 CA 返回证书的有效状态</strong>。</p><p>不必像 CRL 方式客户端需要下载大大的列表，还要从列表查询，同时因为可以实时查询每一张证书的有效性，解决了 CRL 的实时性问题。OCSP 需要向 CA 查询，因此也是要发生网络请求，而且还得看 CA 服务器的 “脸色”，如果网络状态不好，或者 CA 服务器繁忙，也会导致客户端在校验证书这一环节的延时变大</p><p>于是为了解决这一个网络开销，就出现了 <strong>OCSP Stapling</strong>，其原理是：服务器向 CA 周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它。</p><p><img data-src="image/image_okWQn5z9Ud.png" alt=""></p><p>当有客户端发起连接请求时，服务器会把这个「响应结果」在 TLS 握手过程中发给客户端。由于有签名的存在，服务器无法篡改，因此客户端就能得知证书是否已被吊销了，这样客户端就不需要再去查询。</p><h2 id="q什么是会话复用"><a class="anchor" href="#q什么是会话复用">#</a> Q：什么是会话复用？</h2><p>TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？这种方式就是<strong>会话复用</strong>（<em>TLS session resumption</em>），会话复用分两种：</p><ul><li>第一种叫 Session ID；</li><li>第二种叫 Session Ticket；</li></ul><blockquote><p>Session ID</p></blockquote><p>Session ID 的工作原理是，<strong>客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</strong>，Session ID 和会话密钥相当于 key-value 的关系。当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。</p><p>但是它有两个缺点：</p><ul><li>服务器必须保持每一个客户端的会话密钥，随着客户端的增多，<strong>服务器的内存压力也会越大</strong>。</li><li>现在网站服务一般是由多台服务器通过负载均衡提供服务的，<strong>客户端再次连接不一定会命中上次访问过的服务器</strong>，于是还要走完整的 TLS 握手过程；</li></ul><blockquote><p>Session Ticket</p></blockquote><p>为了解决 Session ID 的问题，就出现了 Session Ticket，<strong>服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端</strong>，类似于 HTTP 的 Cookie。客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信</p><p>对于集群服务器的话，<strong>要确保每台服务器加密 「会话密钥」的密钥是一致的</strong>，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。</p><h2 id="qhttps-的应用数据是如何保证完整性的"><a class="anchor" href="#qhttps-的应用数据是如何保证完整性的">#</a> Q：HTTPS 的应用数据是如何保证完整性的？</h2><p>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源。</li></ul><p>TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下</p><ul><li>首先，消息被分割成多个较短的片段，然后分别对每个片段进行压缩。</li><li>接下来，经过压缩的片段会被<strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，</strong> 通过附加消息认证码的 MAC 值，可以识别出篡改。</li><li>再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li><li>最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul><p>记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。</p><h2 id="qhttps-一定安全可靠吗"><a class="anchor" href="#qhttps-一定安全可靠吗">#</a> Q：HTTPS 一定安全可靠吗？</h2><p>假设这样一个场景：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。</p><p>但是要发生这种场景是有前提的，前提是用户点击<strong>接受了中间人服务器的证书。</strong></p><p>中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。</p><p>如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了；如果你的电脑中毒了，被恶意导入了中间人的根证书。那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。</p><p>所以，<strong>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全</strong></p><h2 id="q为什么抓包工具能截取-https-数据"><a class="anchor" href="#q为什么抓包工具能截取-https-数据">#</a> Q：为什么抓包工具能截取 HTTPS 数据？</h2><p>抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任。</p><p>当客户端向服务器发起 HTTPS 请求时，抓包工具会假装是服务器，并向客户端发送自己伪造的数字证书，该证书声称自己是受信任的根证书。客户端收到这个证书后，会检查证书的有效性，如果该证书被标记为受信任的根证书，则客户端会信任这个证书，并将共享密钥等信息使用抓包工具提供的公钥进行加密。这样，抓包工具就能够解密客户端发送的数据，并查看其中的内容。</p><h2 id="q如何避免被中间人抓取数据"><a class="anchor" href="#q如何避免被中间人抓取数据">#</a> Q：如何避免被中间人抓取数据？</h2><p>我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。</p><p>当然，我们还可以通过 <strong>HTTPS 双向认证</strong>。</p><p>一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。</p><p>如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。</p><h2 id="qhttps怎么优化"><a class="anchor" href="#qhttps怎么优化">#</a> Q：HTTPS 怎么优化？</h2><ul><li><p>硬件优化</p><p>HTTPS 协议是计算密集型，而不是 I/O 密集型，所以选一个好的 cpu</p></li><li><p>协议优化</p><ul><li><p>密钥算法优化</p><p>TLS 1.2 版本如果使用的是 RSA 密钥交换算法，那么需要 4 次握手，也就是要花费 2 RTT，才可以进行应用数据的传输，而且 RSA 密钥交换算法不具备前向安全性。</p><p>尽量<strong>选用 ECDHE 密钥交换</strong>算法替换 RSA 算法，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 <strong>TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性</strong></p></li><li><p>TLS 升级</p><p>在 TLS 1.2 的握手中，一般是需要 4 次握手，先要通过 Client Hello （第 1 次握手）和 Server Hello（第 2 次握手） 消息协商出后续使用的加密算法，再互相交换公钥（第 3 和 第 4 次握手），然后计算出最终的会话密钥，</p><p>T<strong>LS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手</strong>。</p><p>怎么合并的呢？具体的做法是，客户端在 Client Hello 消息里带上了支持的椭圆曲线，以及这些椭圆曲线对应的公钥。</p><p>服务端收到后，选定一个椭圆曲线等参数，然后返回消息时，带上服务端这边的公钥。经过这 1 个 RTT，双方手上已经有生成会话密钥的材料了，于是客户端计算出会话密钥，就可以进行应用数据的加密传输了。</p></li></ul></li><li><p>会话重用</p><p>常见的<strong>会话重用</strong>技术有 Session ID 和 Session Ticket，用了会话重用技术，当再次重连 HTTPS 时，只需要 1 RTT 就可以恢复会话。对于 TLS1.3 使用 Pre-shared Key 会话重用技术，只需要 0 RTT 就可以恢复会话，客户端会把 Ticket 和 HTTP 请求一同发送给服务端。</p></li></ul><h2 id="qhttp是无状态的该怎么解决呢"><a class="anchor" href="#qhttp是无状态的该怎么解决呢">#</a> Q：HTTP 是无状态的，该怎么解决呢？</h2><p>首先无状态并不是没有好处的，无状态使得服务器不需要额外的资源存储用户的状态，减轻压力</p><p>为了解决每次访问都要验证身份信息，我们可以采用 cookie，session，jwt 来解决</p><ul><li><p>使用 cookie</p><p>当我们第一次登录时，服务端会存储一份用户信息，并把用户信息返回给客户端，客户端把信息存储到 cookie 中，下次请求会携带 cookie 一起发送给服务器，进行用户的信息验证</p><p>缺点：cookie 存储在浏览器，会有被篡改的风险。cookie 的容量也是有限的。</p></li><li><p>session</p><p>当我们第一次登录时，服务端会将用户信息以 session 的形式存储下来，并返回一个 session ID 给客户端，客户端将这个 id 存储在 cookie。下次请求会携带 session id 发送给服务器，服务器进行查询，进行验证</p><p>缺点：由于服务端要存储 session, 当用户很多时，会占用服务器大量内存</p><p>如果 cookie 被禁用了怎么办？</p><p>可以存储在 localStorage</p><p>可以在请求的 url 以参数的形式声明 session ID</p></li><li><p>jwt</p><p>传统 token 的升级形式。它包含三个部分：头部、payload、签名</p><p>工作流程：</p><p>当用户登录时，服务器会验证用户信息，验证通过后，会生成一个 jwt 返回给客户端</p><p>客户端拿到 jwt 存储起来，下次请求携带 jwt 一起发送给服务器</p><p>服务器会验证签名的完整性，验证成功，则可以请求需要的资源</p><p>优点：jwt 不需要在服务器端存储用户的信息，验证的时候也不需要查库</p></li></ul><h2 id="q携带cookie的http请求是有状态还是无状态的cookie是http协议簇的一部分那为什么还说http是无状态的"><a class="anchor" href="#q携带cookie的http请求是有状态还是无状态的cookie是http协议簇的一部分那为什么还说http是无状态的">#</a> Q：携带 Cookie 的 HTTP 请求是有状态还是无状态的？Cookie 是 HTTP 协议簇的一部分，那为什么还说 HTTP 是无状态的？</h2><p>携带 Cookie 的 HTTP 请求实际上是可以在一定程度上实现状态保持的，因为 Cookie 是用来在客户端存储会话信息和状态信息的一种机制。当浏览器发送包含 Cookie 的 HTTP 请求时，服务器可以通过读取这些 Cookie 来识别用户、管理会话状态以及保持特定的用户状态。因此，可以说即使 HTTP 本身是无状态的协议，但通过 Cookie 的使用可以实现一定程度的状态保持功能。</p><p>HTTP 被描述为 “无状态” 的主要原因是每个 HTTP 请求都是独立的，服务器并不保存关于客户端的状态信息，每个请求都需要提供足够的信息来理解请求的意图。这样的设计使得 Web 系统更具有规模化和简单性，但也导致了一些挑战，比如需要额外的机制来处理用户状态和会话管理。</p><p>虽然 Cookie 是 HTTP 协议簇的一部分，但是 HTTP 协议在设计初衷上仍然保持无状态特性，即每个请求都是相互独立的。使用 Cookie 只是在无状态协议下的一种补充机制，用于在客户端存储状态信息以实现状态保持。</p><h2 id="qjwt的缺点是什么"><a class="anchor" href="#qjwt的缺点是什么">#</a> Q：jwt 的缺点是什么？</h2><p>JWT 一旦派发出去，在失效之前都是有效的，没办法即使撤销 JWT。</p><p>要解决这个问题的话，得在业务层增加判断逻辑，比如增加<strong>黑名单机制。</strong> 使用内存数据库比如 Redis 维护一个黑名单，如果想让某个 JWT 失效的话就直接将这个 JWT 加入到<strong>黑名单</strong> 即可。然后，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。</p><h2 id="qurl和uri的区别"><a class="anchor" href="#qurl和uri的区别">#</a> Q：URL 和 URI 的区别？</h2><p>URL：统一资源定位符，表示资源的路径</p><p>URI：统一资源标识符，唯一标识一个资源</p><h2 id="qcookie和session的区别"><a class="anchor" href="#qcookie和session的区别">#</a> Q：cookie 和 session 的区别？</h2><p>两者都是会话跟踪的技术。</p><ul><li>cookie 存储在浏览器上，session 存储在服务器</li><li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，比如 UserId 等。</li><li>由于 cookie 存储在浏览器，相对来说不安全；而 session 存储在服务器上，相对安全一些</li><li>cookie 如何没有设置了过期时间，即使浏览器关闭，依然有效；而 session 在浏览器关闭后就失效了</li><li>session 存储在服务器上，会话太多的话，服务器压力会过大</li><li>cookie 的容量比较小</li><li>cookie 支持跨域访问，session 不支持</li></ul><h2 id="q如果我把数据存储到-localstorage和cookie有什么区别"><a class="anchor" href="#q如果我把数据存储到-localstorage和cookie有什么区别">#</a> Q：如果我把数据存储到 localStorage，和 Cookie 有什么区别？</h2><ul><li>存储容量: Cookie 的存储容量通常较小，每个 Cookie 的大小限制在几 KB 左右。而 LocalStorage 的存储容量通常较大，一般限制在几 MB 左右。因此，如果需要存储大量数据，LocalStorage 通常更适合；</li><li>数据发送: Cookie 在每次 HTTP 请求中都会自动发送到服务器，这使得 Cookie 适合用于在客户端和服务器之间传递数据。而 localStorage 的数据不会自动发送到服务器，它仅在浏览器端存储数据，因此 LocalStorage 适合用于在同一域名下的不同页面之间共享数据；</li><li>生命周期：Cookie 可以设置一个过期时间，使得数据在指定时间后自动过期。而 LocalStorage 的数据将永久存储在浏览器中，除非通过 JavaScript 代码手动删除；</li><li>安全性：Cookie 的安全性较低，因为 Cookie 在每次 HTTP 请求中都会自动发送到服务器，存在被窃取或篡改的风险。而 LocalStorage 的数据仅在浏览器端存储，不会自动发送到服务器，相对而言更安全一些；</li></ul><h2 id="qcookie有哪些风险"><a class="anchor" href="#qcookie有哪些风险">#</a> Q：cookie 有哪些风险？</h2><ul><li><p>跨站脚本攻击（XSS), 用户登录了被注入了脚本的网站，恶意脚本会执行，从而获取用户信息</p><p>预防 XSS 攻击的方法主要包括以下几点：</p><ul><li>输入验证：对所有用户输入的数据进行有效性检验，过滤或转义特殊字符。例如，禁止用户输入 HTML 标签和 JavaScript 代码。</li><li>输出编码：在网页输出用户输入内容时，使用合适的编码方式，如 HTML 转义、URL 编码等，防止恶意脚本注入。</li><li>Content Security Policy（CSP）：通过设置 CSP 策略，限制网页中可执行的脚本源，有效防范 XSS 攻击。</li><li>使用 HttpOnly 标记：在设置 Cookie 时，设置 HttpOnly 属性，使得 Cookie 无法被 JavaScript 代码读取，减少受到 XSS 攻击的可能。</li></ul></li><li><p>会话劫持，cookie 泄漏后，攻击者会获取 session ID，从而冒充用户登录会话，做一些危险操作</p></li><li><p>跨站请求伪造（CSRF): 一种冒充用户向服务器发送伪造请求的攻击。它通常是在用户登录状态下，诱使用户访问恶意网站，从而利用用户的身份信息向其他服务器发送请求。</p><p><img data-src="image/image_GHCblDrjcF.png" alt=""></p><p>解决 CSRF 攻击的方法主要有以下几种：</p><ol><li>验证用户会话：在服务器端对用户会话进行验证，确保请求的会话标识符与当前会话标识符匹配。这样可以防止攻击者伪造会话标识符。</li><li>使用双重验证：除了会话验证，还可以使用其他验证方式，例如验证码、签名验证等。这些验证方式可以增加攻击的难度。</li><li>防止跨站请求：通过设置 CSP（内容安全策略）来防止跨站请求，限制网页中可执行的脚本源，减少攻击者诱导用户执行恶意操作的可能性。</li><li>避免使用自动提交表单：禁用默认的自动提交功能，要求用户在提交表单前确认操作，防止攻击者诱导用户在未经授权的情况下提交表单。</li><li>强制 Referer 头部：在服务器端检查请求的 Referer 头部，确保请求来自可信来源</li></ol></li></ul><h2 id="qcookie支持跨域访问吗"><a class="anchor" href="#qcookie支持跨域访问吗">#</a> Q：cookie 支持跨域访问吗？</h2><p>默认是不支持，但可以设置。设置服务器响应头为支持跨域，并且后台配置支持跨域的域名。</p><h2 id="qget和post的区别"><a class="anchor" href="#qget和post的区别">#</a> Q：GET 和 POST 的区别？</h2><ul><li>从语义上看，get 是从服务器获取资源，而 post 是创建或者修改资源</li><li>get 的是幂等的，多次操作并不会改变资源。而 post 则不是幂等的，它可能会改变资源的状态</li><li>由于 get 是幂等的，所以可以使用缓存，把经常访问的资源缓存下来</li><li>get 请求的 url 是有限的，而 post 请求的 body 原则上是没有限制的</li><li>Get 报文的请求参数直接显式地放在 URL 里，而 post 报文的请求参数放在 body 里，相对安全。而且因为 URL 只支持 ASCII 码，所以 Get 的参数只能是 ASCII 码，而 post 的 body 可以是任意格式的数据</li></ul><h2 id="qget-请求可以带-body-吗"><a class="anchor" href="#qget-请求可以带-body-吗">#</a> Q：GET 请求可以带 body 吗？</h2><h2 id="qwebsocket是什么为什么还要有websocket"><a class="anchor" href="#qwebsocket是什么为什么还要有websocket">#</a> Q：webSocket 是什么？为什么还要有 webSocket?</h2><p>webSocket 是一个建立在 TCP 上的全双工通信协议。也就说服务器也可以给客户端推送信息。</p><p>webSocket 建立连接的过程是这样的：</p><ul><li>客户端发送一个 http 请求，请求中要求升级连接为 webSocket，并带上一个随机生成的 base64 码</li><li>服务器收到后，用一个公开的算法将 base64 码转换成一段字符串，返回给客户端，并返回状态码 101</li><li>客户端收到后，同样的公开的算法对 base64 码进行转换，比较和服务器发过来的字符串是否一致，一致则升级成功</li></ul><p>webSocket 适合客户端和服务器频繁交互的场景下使用，如网页游戏、网页聊天室</p><ol><li><strong>双向通信</strong>：WebSocket 支持全双工通信，客户端和服务器可以同时进行双向数据传输，而不像 HTTP 协议只能通过请求 - 响应模式进行单向通信。</li><li><strong>低延迟</strong>：由于 WebSocket 使用持久连接，避免了 HTTP 的连接建立和断开的开销，因此可以实现更低的通信延迟，适用于实时性要求高的应用场景，如在线游戏、实时聊天等。</li><li><strong>更小的数据传输开销</strong>：WebSocket 使用二进制帧来传输数据，相比于 HTTP 的文本数据传输，可以减少数据传输的开销，提高传输效率。</li><li><strong>更少的网络流量</strong>：WebSocket 使用更少的 HTTP 头信息，而且在建立连接之后可以发送较小的数据帧，因此相比于长轮询或者轮询等技术，WebSocket 在网络传输方面具有更少的开销。</li><li><strong>支持跨域通信</strong>：WebSocket 支持跨域通信，可以通过 CORS（跨域资源共享）机制进行跨域资源访问控制，方便在不同域名下进行实时数据交换。</li><li><strong>实时性和可靠性</strong>：WebSocket 可以建立持久连接，并且支持心跳检测等机制，可以实时监测连接状态，确保通信的可靠性，适用于需要长时间保持连接的场景。</li></ol><h2 id="q简述-cors-的工作原理"><a class="anchor" href="#q简述-cors-的工作原理">#</a> Q：简述 CORS 的工作原理</h2><p>CORS（Cross-Origin Resource Sharing，跨源资源共享）是一种机制，它使用 HTTP 头允许或限制不同源之间的资源共享。CORS 解决了浏览器的同源策略限制，使得网页能够安全地请求来自不同域的资源。</p><p>所谓的同源策略，在浏览器中，同源策略限制了从不同源（协议、域名和端口均不同）加载的资源。例如，域名为 <code>example.com</code> 的页面无法直接请求 <code>another-domain.com</code> 上的资源。这是为了防止恶意网站窃取用户数据。</p><blockquote><p>CORS 的工作原理</p></blockquote><ol><li><strong>请求阶段</strong>：</li></ol><ul><li>当网页尝试从不同源发出请求时，浏览器会首先检查 CORS 策略。</li><li>对于跨源请求，浏览器会自动添加 CORS 请求头。</li></ul><ol><li><strong>简单请求和预检请求</strong>：</li></ol><ul><li><strong>简单请求</strong>：针对 GET、POST（符合特定条件，如 Content-Type 为 <code>application/x-www-form-urlencoded</code> 、 <code>multipart/form-data</code> 或 <code>text/plain</code> ）等安全请求，直接发送请求。</li><li><strong>预检请求</strong>：如果请求的 HTTP 方法为 PUT、DELETE 或使用了自定义的请求头，浏览器会先发送一个 OPTIONS 请求到服务器，询问目标资源的 CORS 允许情况，这被称为预检请求。</li></ul><ol><li><strong>服务器响应</strong>：</li></ol><ul><li><code>Access-Control-Allow-Origin</code> ：指定允许访问的源，可以是特定源或 <code>*</code> （允许所有源）。</li><li><code>Access-Control-Allow-Methods</code> ：指定允许的 HTTP 方法（如 GET、POST、PUT 等）。</li><li><code>Access-Control-Allow-Headers</code> ：允许的请求头，主要用于自定义请求头的情况。</li><li><code>Access-Control-Max-Age</code> ：表示预检请求的有效期。</li><li>服务器需要在响应中包含 CORS 相关的 HTTP 头，指示是否允许该跨源请求。主要的 CORS 响应头包括：</li></ul><ol><li><strong>浏览器处理响应</strong>：</li></ol><ul><li>如果服务器响应的 CORS 头匹配请求的源和相关设置，浏览器允许请求的结果继续处理。</li><li>如果 CORS 配置不匹配，浏览器会阻止请求并发出错误。</li></ul><blockquote><p>工作流程示例</p></blockquote><ol><li><strong>发起请求</strong>：</li></ol><ul><li>用户在 <code>http://example.com</code> 的页面中发起向 <code>http://api.example.com/data</code> 的 AJAX 请求。</li></ul><ol><li><strong>浏览器发起预检请求</strong>（如果是跨域 POST 等）：</li></ol><ul><li>浏览器发送一个 OPTIONS 请求：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /data HTTP/1.1   </span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>服务器响应</strong>：</li></ol><ul><li>服务器响应包含 CORS 相关头：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 204 No Content   </span><br><span class="line">Access-Control-Allow-Origin: http://example.com   </span><br><span class="line">Access-Control-Allow-Methods: GET, POST</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>发送实际请求</strong>：</li></ol><ul><li>如果预检请求成功，浏览器将发送实际的请求（如 POST）。</li><li>服务器再次返回数据，并包含 CORS 头，允许浏览器处理响应。</li></ul><h2 id="qwebsocket如何验证身份"><a class="anchor" href="#qwebsocket如何验证身份">#</a> Q：websocket 如何验证身份？</h2><p>jwt?</p><h2 id="qping命令是什么工作原理又是什么"><a class="anchor" href="#qping命令是什么工作原理又是什么">#</a> Q：PING 命令是什么？工作原理又是什么？</h2><p>ping 是用来检测发送方到服务器之间的网络状态和网络延迟</p><p>ping 命令主要用了 ICMP (互联网控制报文协议），ICMP 主要分为两类，一类是查询报文，向目标主机发送请求并要求回应；另一类是差错报文，向源主机回报网络错误。ping 命令中，发送的是 ICMP echo 请求报文，如果通信正常，会返回 ICMP echo reply。</p><h2 id="qdns是什么解析过程是怎样的"><a class="anchor" href="#qdns是什么解析过程是怎样的">#</a> Q：DNS 是什么？解析过程是怎样的？</h2><p>Domain Name System（域名系统）</p><p>DNS 是将域名解析成对应的 IP 地址，端口号为 53；</p><p>解析有两种过程，一种是迭代，一种是递归。迭代在 输入 url 会发生什么有介绍，这里说一下递归的形式。</p><p>本地 DNS 域名服务器没有查到，会向根域名服务器发送请求，根域名服务器收到后，会向对应的顶级域名服务器发送查询请求，顶级域名服务器收到后向对应的权威域名服务器发送请求，权威域名服务器查出结果，会一层一层向上，返回给根域名服务器，最后返回给本地域名服务器。</p><h2 id="qdns基于tcp还是udp为什么"><a class="anchor" href="#qdns基于tcp还是udp为什么">#</a> Q：DNS 基于 TCP 还是 UDP？为什么？</h2><p>DNS 基于 UDP 协议实现，DNS 使用 UDP 协议进行域名解析和数据传输。因为基于 UDP 实现 DNS 能够提供低延迟、简单快速、轻量级的特性，更适合 DNS 这种需要快速响应的域名解析服务。</p><ul><li><strong>低延迟：</strong> UDP 是一种无连接的协议，不需要在数据传输前建立连接，因此可以减少传输时延，适合 DNS 这种需要快速响应的应用场景。</li><li><strong>简单快速：</strong> UDP 相比于 TCP 更简单，没有 TCP 的连接管理和流量控制机制，传输效率更高，适合 DNS 这种需要快速传输数据的场景。</li><li><strong>轻量级</strong>：UDP 头部较小，占用较少的网络资源，对于小型请求和响应来说更加轻量级，适合 DNS 这种频繁且短小的数据交换。</li></ul><h2 id="qdns劫持是什么怎么解决"><a class="anchor" href="#qdns劫持是什么怎么解决">#</a> Q：DNS 劫持是什么？怎么解决？</h2><p>DNS 劫持是通过某些手段获得域名的解析控制权，返回给用户一个错误的 IP 地址。</p><p>劫持方法：DNS 重定向 (还有其他的，不想记）</p><p>解决方法：公司准备两个域名；手动修改 DNS;</p><h2 id="qtcp头部字段有哪些"><a class="anchor" href="#qtcp头部字段有哪些">#</a> Q：TCP 头部字段有哪些？</h2><p>有很多，可以挑几个重要的说一下：</p><ul><li>源端口号：发送方的端口号（16 位）</li><li>目的端口号</li><li>序号：发送方每次发数据会携带一个序号，用来解决网络包乱序的问题</li><li>确认号：接收方收到数据后，会返回一个确认号，表示确认号之前的数据都收到了</li><li>窗口：告诉发送方自己还可以接收多少数据</li><li>控制位<ul><li>ACK: 等于 1 表示确认有效</li><li>SYN: 建立连接时用到</li><li>FIN：释放连接时使用到</li></ul></li><li>校验和：校验首部和数据</li></ul><h2 id="qudp头部字段有哪些"><a class="anchor" href="#qudp头部字段有哪些">#</a> Q：UDP 头部字段有哪些？</h2><ul><li>源端口号</li><li>目的端口号</li><li>校验和：UDP 校验和主要用于检测数据在传输过程中是否发生了错误或损坏。但不保证检验和通过，数据一定正确，可能存在冗余碰撞（计算出的校验和是一样的），恶意篡改 (数据和校验和一起篡改了）；</li><li>UDP 长度，没有数据就是 8 字节</li></ul><h2 id="q为什么要有tcp工作在哪一层"><a class="anchor" href="#q为什么要有tcp工作在哪一层">#</a> Q：为什么要有 TCP? 工作在哪一层？</h2><p>（其实就是问 tcp 作用）</p><p>TCP 可以保证数据的无差错，有序，无冗余。它是工作在传输层的</p><h2 id="q-什么是tcp连接"><a class="anchor" href="#q-什么是tcp连接">#</a> Q : 什么是 TCP 连接？</h2><p>tcp 由四元组确立，源 ip 地址，源端口，目的地址，目的端口</p><h2 id="q有一个-ip-的服务端监听了一个端口它的-tcp-的最大连接数是多少"><a class="anchor" href="#q有一个-ip-的服务端监听了一个端口它的-tcp-的最大连接数是多少">#</a> Q：有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</h2><p>服务端 ip 地址，端口固定的话，但是客户端的 ip，端口是可变的</p><p>所以最大连接数为 ： 客户端 ip 数 * 客户端端口数</p><p>ip 地址是 32 位，端口是 16 位，所以理论上最多 2^32 *2^16 = 2^48 个连接</p><p>但是会受到一些因素限制，比如</p><p>文件描述符，一个连接就是一个文件，所以受到文件描述符的数量限制</p><p>内存大小：连接是占用内存的，连接过多会出现内存溢出的错误</p><h2 id="qudp和tcp区别"><a class="anchor" href="#qudp和tcp区别">#</a> Q：UDP 和 TCP 区别？</h2><ul><li><p>从头部字段上看，tcp 的头部字段很多，udp 很少；tcp 长度至少 20 字节，udp 头部长度固定 8 字节</p></li><li><p>tcp 是面向连接的，udp 是无连接的</p></li><li><p>tcp 保证数据无差错，无重复，无丢失，有序到达；udp 是尽最大努力传输数据，不保证数据的可靠性</p></li><li><p>tcp 提供流量控制，拥塞控制，udp 则没有</p></li><li><p>tcp 是面向字节流传输的，udp 则是面向报文传输</p></li><li><p>tcp 是一对一传输，udp 可以一对一，一对多，多对多传输</p></li><li><p>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</p><p>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</p></li></ul><h2 id="qudp和tcp应用场景"><a class="anchor" href="#qudp和tcp应用场景">#</a> Q：UDP 和 TCP 应用场景？</h2><p>tcp 适用于一些需要保证传输可靠的场景，比如说文件传输，http</p><p>udp 适合需要快速传输，对可靠性要求不高的场景，比如广播通信，视频，音频，DNS</p><h2 id="q为什么-udp-头部没有首部长度字段而-tcp-头部有首部长度字段呢"><a class="anchor" href="#q为什么-udp-头部没有首部长度字段而-tcp-头部有首部长度字段呢">#</a> Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</h2><p>udp 首部长度是固定的 8 字节，tcp 头部长度不是固定，它有一个选项字段（以后的扩展），可以改变首部长度</p><h2 id="q为什么-udp-头部有包长度字段而-tcp-头部则没有包长度字段呢"><a class="anchor" href="#q为什么-udp-头部有包长度字段而-tcp-头部则没有包长度字段呢">#</a> Q：为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</h2><p>tcp 的数据长度可以根据 ip 长度 - ip 首部长度 - tcp 首部长度得到</p><p>udp 不也能根据这个公式计算吗？</p><p>可能的原因：</p><ul><li>可能是用来保证头部的长度是 4 字节的倍数（凑字数用的）</li><li>可能原来 udp 不是基于 ip 发展来的，原来是不能用这个公式计算</li></ul><h2 id="qtcp-和-udp-可以使用同一个端口吗"><a class="anchor" href="#qtcp-和-udp-可以使用同一个端口吗">#</a> Q：TCP 和 UDP 可以使用同一个端口吗？</h2><p>其他问法：可以绑定一个端口吗？可以监听同一个端口吗？</p><p>可以。</p><p>tcp 和 udp 在内核中是两个独立的模块，主机收到数据号，根据协议号判断是发送给 tcp 还是 udp 处理，两者可以拥有相同的端口</p><h2 id="q多个-tcp-服务进程可以绑定同一个端口吗"><a class="anchor" href="#q多个-tcp-服务进程可以绑定同一个端口吗">#</a> Q：多个 TCP 服务进程可以绑定同一个端口吗？</h2><p>这里首先要看 ip 地址是不是一样，如果 ip 地址，端口号都一样，那么就不可以</p><p>如果 ip 地址不同，则可以</p><p>注意：如果绑定的 0.0.0.0 地址，那么即使 ip 地址不相同，也不允许绑定，因为这个地址比较特殊，代表所有的地址</p><p>除此之外，如果真想多个 tcp 进程绑定相同的 ip 地址和端口号，那么可以设置 socket 中的 SO_REUSEPORT 属性，它可以做到端口复用，一般是用来负载均衡、并发连接的处理。</p><h2 id="q重启-tcp-服务进程时为什么会有address-in-use的报错信息怎么避免"><a class="anchor" href="#q重启-tcp-服务进程时为什么会有address-in-use的报错信息怎么避免">#</a> Q：重启 TCP 服务进程时，为什么会有 “Address in use” 的报错信息？怎么避免？</h2><p>我们重启 tcp 进程，相当于服务器发起关闭连接的操作，那么会经过四次挥手过程，服务器最终不会立马关闭连接，而是会进入到 time_wait 状态，时间为 2msl。重启 tcp 进程时，这个 ip + 端口的组合还不允许绑定，所以会出现错误</p><p>可以设置 socket 的 SO_REUSEADDR 属性，就可以绑定成功</p><h2 id="q-客户端可以用同一个端口吗多个客户端可以-bind-同一个端口吗"><a class="anchor" href="#q-客户端可以用同一个端口吗多个客户端可以-bind-同一个端口吗">#</a> Q : 客户端可以用同一个端口吗？多个客户端可以 bind 同一个端口吗？</h2><p>连接时，客户端内核会从给定范围随机（默认值是 32768 61000，大概 28322 个）挑选一个端口。</p><p>一个 tcp 连接是由四元组决定，所以 ip 地址不一样，端口是可以一样的</p><h2 id="q客户端-tcp-连接-time_wait-状态过多会导致端口资源耗尽而无法建立新的连接吗"><a class="anchor" href="#q客户端-tcp-连接-time_wait-状态过多会导致端口资源耗尽而无法建立新的连接吗">#</a> Q：客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</h2><p>如果是同一个服务器，也就是目标 IP 地址和端口号是一样的。那么如果 time_wait 状态过多，会导致端口用尽，无法建立连接</p><p>如何解决呢？</p><p>可以启动内核中的一个参数 net.ipv4.tcp_tw_reuse，打开参数后，如果在 connect 的时候，选择的端口已经被占用，而且当前的连接的状态是 time_wait, 会查看当前的 time_wait 时间已经超过一秒，就会重用该连接。</p><p>需要注意的是该参数是客户端执行 connection 时调用的，服务端设置是没用的</p><p>除此之外如果连接的是不同的服务器，端口是可以重复使用的</p><h2 id="q客户端端口选择的过程是怎样的"><a class="anchor" href="#q客户端端口选择的过程是怎样的">#</a> Q：客户端端口选择的过程是怎样的？</h2><ul><li>首先查看是否调用了 bind ()，如果调用了 bind ()，则直接使用 bind 绑定的端口</li><li>如果没有调用 bind, 从给定的端口随机选择一个端口</li><li>如果端口没使用，则直接使用。如果端口使用了，进一步判断现有的连接中是否有和现在要建立的连接的四元组是否一样</li><li>如果不一样，端口则可用。如果一样，判断是否打开了 tcp_tw_reuse 参数，没打开，则重新选择端口号</li><li>如果打开了，判断连接状态是否处于 time_wait 状态，并且已经超过 1 秒了。则可以重用该端口</li><li>如果没打开，那么重新选择端口</li></ul><p><img data-src="image/image_C8BBvz_rsH.png" alt=""></p><h2 id="q使用tcp的协议有哪些使用udp的协议有哪些"><a class="anchor" href="#q使用tcp的协议有哪些使用udp的协议有哪些">#</a> Q：使用 TCP 的协议有哪些？使用 UDP 的协议有哪些？</h2><ul><li><p>TCP</p><p>HTTP (3.0 之前）</p><p>FTP：用于文件传输，不是安全的，明文传输</p><p>SMTP: 发送邮件</p><p>POP3: 接收邮件</p><p>SSH: 远程登录</p><p>Telnet: 远程登录</p></li><li><p>UDP</p><p>DNS</p><p>HTTP/3.0</p><p>DHCP: 动态分配 ip</p></li></ul><h2 id="qtcp三次握手过程"><a class="anchor" href="#qtcp三次握手过程">#</a> Q：TCP 三次握手过程？</h2><ul><li><p>一开始客户端和服务端都处于 close 状态，服务器开始监听一个端口，进入 listen 状态</p></li><li><p>客户端向服务端发送连接，客户端会随机生成一个序号，假设为 x, 并且把标识位 SYN 设置为 1，</p><p>客户端发送连接后进入到 SYN_SEND 状态</p></li><li><p>服务器收到后，在发送的报文中，也会随机生成一个序号，假设为 y, 设置确认序号为 x+1, 设置标识位 ack=1,syn=1, 发送完之后，服务器进入 syn_recv 状态</p></li><li><p>客户端收到后，还要向服务端发送一个回应报文。设置确认序号为 y+1，设置标识位 ack=1, 发送完之后，客户端进入 established 状态（<strong>第三次握手是可以携带数据的</strong>）</p></li></ul><h2 id="q为什么是三次握手而不是两次或者四次"><a class="anchor" href="#q为什么是三次握手而不是两次或者四次">#</a> Q：为什么是三次握手，而不是两次或者四次？</h2><p>首先为什么不是两次，主要有几个原因，首先是避免历史连接</p><p>假设这样一个场景，客户端发起一个连接请求后，突然宕机了，这个请求由于网络原因阻塞一段时间，等到客户端重启后，重新又发送了一次连接（注意两次前后序号是不一样的，超时重传是一样的), 这时旧的连接到达了服务器，由于是两次握手，服务器发送完确认报文，就可以直接发送数据了。但是确认报文到达客户端后，后端发现确认序号并不是它需要的，所以它会发送 RST 去终止连接。并且这中间服务器发送的数据，客户端也不会接受，这就导致数据白白浪费了。</p><p>这里可能面试官会反问三次握手可以避免此情况呢？</p><p>因为是三次握手，所以第二次服务器发送确认后，并不会立即发送数据。</p><p>其次是同步双方的初始序列号。</p><p>如果是两次握手，服务器并不知道客户端是否收到了自己初始序列号，如果这个确认报文丢失了，那么双方序列号就不能达成一致</p><p>为什么要达成一致呢？</p><p>序号的作用是能保证数据的无重复，有序。如果客户端不知道服务器发送的序号，那么它发送数据的时候就不知道在自己的确认序号中填什么字段</p><p>最后避免资源的浪费</p><p>假设客户端发送的连接请求在网络中阻塞了，客户端超时重传了又发了一个连接请求，由于是两次握手，服务器不知道自己的确认客户端是否收到，所以它每收到一个 syn 请求就会先建立连接，这就会导致建立了重复冗余的连接</p><p>为什么不是四次？三次已经可以建立连接了，所以没必要四次了</p><h2 id="q客户端发送三次握手ack-报文后就可以发送数据了而被动方此时还是-syn_received-状态如果-ack-丢了那客户端发的数据是不是也白白浪费了"><a class="anchor" href="#q客户端发送三次握手ack-报文后就可以发送数据了而被动方此时还是-syn_received-状态如果-ack-丢了那客户端发的数据是不是也白白浪费了">#</a> Q：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</h2><p>不是的，即使服务端还是在 syn_received 状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ack 标识位，也有确认号，这个确认号就是确认收到了第二次握手。</p><p>所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了。</p><h2 id="q为什么每次建立-tcp-连接时初始化的序列号都要求不一样呢"><a class="anchor" href="#q为什么每次建立-tcp-连接时初始化的序列号都要求不一样呢">#</a> Q：为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h2><p>主要为了防止历史报文被下一个连接所接收</p><p>假设这样一个场景，客户端和服务器建立了连接，客户端发送了一个数据包给服务器，数据包阻塞了，这时客户端断电重启了。重启完又重新建立了一个连接，这时网络中的历史报文到达了服务器，由于使用是一样的初始化报文，那很可能这段报文会刚好在服务器的接收窗口内，造成数据的混乱</p><h2 id="q初始序列号-isn-是如何随机产生的"><a class="anchor" href="#q初始序列号-isn-是如何随机产生的">#</a> Q：初始序列号 ISN 是如何随机产生的？</h2><p>ISN 随机生成算法：ISN = M + F (localhost, localport, remotehost, remoteport)。</p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul><p>M 是递增的，所以基本不可能出现一样的序号</p><h2 id="q客户端和服务端初始化序列号都是随机生成的话就一定能避免连接接收历史报文吗"><a class="anchor" href="#q客户端和服务端初始化序列号都是随机生成的话就一定能避免连接接收历史报文吗">#</a> Q：客户端和服务端初始化序列号都是随机生成的话，就一定能避免连接接收历史报文吗？</h2><p><strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据</strong>。在一个速度足够快的网络中传输大量数据时，序列号的回绕时间就会变短。如果序列号回绕的时间极短，我们就会再次面临之前延迟的报文抵达后序列号依然有效的问题。</p><p>为了解决这个问题，就需要有 TCP 时间戳。tcp_timestamps 参数是默认开启的，开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p><p>时间戳也可能回绕，可以增加时间戳的大小。</p><h2 id="q既然ip层会进行分片为什么tcp层还需要mss"><a class="anchor" href="#q既然ip层会进行分片为什么tcp层还需要mss">#</a> Q：既然 IP 层会进行分片，为什么 TCP 层还需要 MSS？</h2><p>MTU 是允许网络包的最大长度，它包括 IP 头部 + TCP 头部 + TCP 数据</p><p>而 MSS 指的是 TCP 数据长度</p><p>当数据包长度超过 MTU，会进行分片。如果没有 MSS，我们把一个 TCP 报文全部交给 IP 层分片，假设其中一个分片丢失了，因为 ip 层没有重传机制，需要交给 tcp 重传，那么整个 TCP 报文就会进行重传。而有了 MSS，丢失了会以 MSS 为单位重传，极大的提高了重传的效率。</p><h2 id="q第一次挥手丢失会怎样第二次挥手丢失会怎样第三次挥手丢失会怎样"><a class="anchor" href="#q第一次挥手丢失会怎样第二次挥手丢失会怎样第三次挥手丢失会怎样">#</a> Q：第一次挥手丢失会怎样？第二次挥手丢失会怎样？第三次挥手丢失会怎样？</h2><ul><li>第一次挥手丢失后，由于迟迟收不到 ACK，会重新发送</li><li>第二次挥手丢失后，由于服务器迟迟收不到客户端的 ACK，会重新发送。除此之外，由于客户端迟迟收不到服务器的 ACK，会认为服务器没有收到第一次握手的请求，所以客户端也会重传</li><li>第三次挥手丢失后，由于服务器迟迟收不到客户端的 ACK，会重新发送</li></ul><h2 id="q什么是syn攻击如何避免"><a class="anchor" href="#q什么是syn攻击如何避免">#</a> Q：什么是 SYN 攻击？如何避免？</h2><p>tcp 建立连接，linux 内核会维护两个队列，一个是 syn 队列，一个是 accept 队列。服务器收到客户端的 syn 报文时，会创建一个半连接对象加入到 syn 队列。接着发送 SYN+ACK 报文给客户端，客户端发送 ACK 给服务器。服务器收到 ACK 之后，会从 syn 队列取出一个半连接对象，建立一个全连接对象进入到 accept 队列。之后调用 accept () 取出一个全连接对象。</p><p>syn 攻击就是攻击者疯狂发送 syn 连接，服务器收到后，会发送 ack，但是无法收到客户端回复的 ack。这样就会导致 syn 队列被撑满，导致正常的连接被拒绝。</p><p>解决方案：</p><p>可以增大 syn 队列的长度；</p><p>可以开启 net.ipv4.tcp_syncookies，开启之后，当 syn 队列满时，并不会拒绝请求，会计算一个 cookie 值放到确认报文中，返回给客户端，相当于绕过了 syn 半连接的建立，服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」</p><p>可以减少重传次数。当服务器迟迟收不到客户端的 ack，会触发重传，重传到一定次数，会断开连接。那么我们可以减少重传次数，加快断开连接的速度</p><h2 id="qtcp四次挥手过程是怎样的"><a class="anchor" href="#qtcp四次挥手过程是怎样的">#</a> Q：TCP 四次挥手过程是怎样的？</h2><p>客户端发起断开连接请求，设置标识位 FIN=1，之后进入 FIN_WAIT_1 状态。</p><p>服务器收到请求后，返回 ACK 报文，之后进入 CLOSE_WAIT 状态</p><p>此时服务器还是可以发送数据给客户端的，当服务器没有数据发送时，发送 FIN 报文给客户端，进入到 LAST_ACK 状态</p><p>客户端收到后，发送 ACK 报文给服务器，之后进入 time_wait 状态（只有主动关闭，才会有 time_wait 状态）。服务器收到确认之后就进入到 close 状态。客户端这边等待 2msl 之后，也进入到 close 状态。</p><h2 id="q为什么是四次握手"><a class="anchor" href="#q为什么是四次握手">#</a> Q：为什么是四次握手？</h2><p>因为当服务器发送 ACK 报文之后，可能还有数据要发送，等到数据发送完了，再发送 FIN 报文，所以总共要四次。</p><p>不过在服务端没有数据发送并且开启了 TCP 延迟确认的情况下，可以短缩为 3 次。</p><p>TCP 延迟确认：</p><p>如果只是发送不带数据的 ACK，效率是不高的，头部就占用了 40 字节（IP 头部和 TCP 头部）</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul><h2 id="q第一次-二次-三次-四次挥手丢失会怎样"><a class="anchor" href="#q第一次-二次-三次-四次挥手丢失会怎样">#</a> Q：第一次、二次、三次、四次挥手丢失会怎样？</h2><ol><li><p>第一次挥手丢失</p><p>客户端迟迟没有收到 ACK，会重新发送</p></li><li><p>第二次丢失</p><p>客户端迟迟没有收到 ACK，<strong>客户端</strong>会重新发送</p></li><li><p>第三次丢失</p><p>服务器迟迟没有收到 ACK，服务器会重新发送</p></li><li><p>第四次丢失</p><p>服务器迟迟没有收到 ACK，服务器会重新发送</p></li></ol><h2 id="q为什么time_wait的时间是2msl"><a class="anchor" href="#q为什么time_wait的时间是2msl">#</a> Q：为什么 time_wait 的时间是 2MSL?</h2><p>MSL 报文在网络中最大存活的时间，如果客户端第四次挥手发送的 ACK 丢失了，服务器因为迟迟收不到 ACK 而会重发 FIN，这样一来一回总共 2MSL。客户端收到是重发的 FIN，会重置 time_wait 时间</p><p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><p>如果服务器重发的 FIN 也丢失呢？</p><p>TCP 中有冗余 FIN 机制，原先的连接已经关闭了（因为在 2msl 内没收到重发的 fin), 之后服务器重发 fin 也不会接收，因为 fin 的序号和新的序号是不匹配的</p><h2 id="q为什么需要time_wait状态"><a class="anchor" href="#q为什么需要time_wait状态">#</a> Q：为什么需要 time_wait 状态？</h2><ol><li><p>防止历史数据的影响</p><p>假设有服务器之前发送的历史数据在传输过程中阻塞了，如果没有 time_wait 状态，客户端发送完 ack 直接关闭。等下次如果建立同样的连接，历史数据可能刚好在客户端的接收窗口内，造成数据混乱</p></li><li><p>确保服务器能接收到 ACK 报文，从而帮助其正常关闭。</p><p>如果没有 time_wait 状态，如果第四次挥手丢失，服务器会重发 FIN，客户端收到到会认为是非法报文，会回复一个 RST，服务器收到后解释成一个错误，这对于一个可靠的协议来说不是优雅的关闭方式</p></li></ol><h2 id="qtime_wait状态过多的危害"><a class="anchor" href="#qtime_wait状态过多的危害">#</a> Q：time_wait 状态过多的危害？</h2><ul><li>占用系统资源，比如内存，文件描述符</li><li>客户端的端口是有限的，time_wait 状态过多，会造成端口号资源受限</li></ul><h2 id="q如何优化time_wait"><a class="anchor" href="#q如何优化time_wait">#</a> Q：如何优化 time_wait?</h2><ul><li>开启 tcp_te <em>reuse（记不住就直接 reuse), 这可以使客户端复用 time</em>_wait 状态超过 1s 的连接</li><li>设置<em> tcp_max_tw_buckets</em>，超过设置数量，后面的连接状态为 time_wait 会直接重制</li><li>对于服务器端过多的 time_wait, 就是不要主动关闭连接，交给客户端去处理这些 time_wait</li></ul><h2 id="q服务器出现大量-time_wait-状态的原因有哪些"><a class="anchor" href="#q服务器出现大量-time_wait-状态的原因有哪些">#</a> Q：服务器出现大量 TIME_WAIT 状态的原因有哪些？</h2><p>首先只有主动关闭才会有 time_wait 状态，服务器出现大量 time_wait 状态意味着服务器主动关闭了大量 TCP 连接。一般都是客户端主动关闭，所以问题转化为了服务器什么情况下会主动关闭 tcp 连接？</p><ol><li><p>大量短连接，没有使用长连接</p><p>在大多 Web 的实现中，使用短连接时，也就是双方任何一方没有开启 keep_alive 时，关闭连接时，一般都是服务器主动关闭</p><p>为什么会这样设计？（不问就别说，避免给自己刨坑）</p><ol><li>情况 1: 客户端禁用了 keep_alive, 服务端没有。那么不再重用这个连接的时机只有在服务器了，因为客户端已经表示不再重用了</li><li>情况 2: 客户端开启了，服务器禁用。服务器主动关闭更加的方便，一次系统调用就可以了。</li></ol></li><li><p>长连接超时</p><p>对于一个长连接，客户端长时间没有再发送数据，就会触发长连接超时机制，服务器主动关闭长连接</p></li><li><p>长连接中请求超过限制</p><p>一个长连接中的请求如果过多，超时了限制，服务器也会主动关闭连接</p></li></ol><h2 id="q-服务器出现大量close_wait状态"><a class="anchor" href="#q-服务器出现大量close_wait状态">#</a> Q ：服务器出现大量 close_wait 状态？</h2><p>close_wait 状态只有被动关闭连接才会出现。是在第二次挥手后，出现的状态 。</p><p>通常都是代码问题，导致服务器迟迟没有调用 close () 函数，进入不到 LAST_ACK 状态</p><p>比如说没有将 socket 注册到 epoll () 中；没有使用 accept 接收已连接的 socket</p><h2 id="qtcp如何保证数据的可靠"><a class="anchor" href="#qtcp如何保证数据的可靠">#</a> Q：TCP 如何保证数据的可靠？</h2><p>这个问题很大，可以讲很多</p><ul><li><p>序号机制。TCP 采用序号机制，每一个数据包都会有一个序号，保证数据不会重复，按序到达</p></li><li><p>重传机制，</p><ul><li>重传机制有超时重传，当发送一个报文而很长时间没有收到确认，就是重传该报文。</li><li>超时重传的等待时间比较长，所以还有一种快速重传。当发送方连续收到三个相同的 ACK，就会重传报文</li><li>还有一个问题，就是重传的时候，要不要把丢失报文之后的报文也全部重传呢。所以提供了选择性重传的机制，它在头部添加了一个 SACK 的东西，告诉发送方自己哪些数据收到了。所以发送方只需要重发丢失的数据。</li><li><code>D-SACK</code> 其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。有这么几个好处：<ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了；</li><li>可以知道是不是「发送方」的数据包被网络延迟了；</li><li>可以知道网络中是不是把「发送方」的数据包给复制了；</li></ol></li></ul></li><li><p>流量控制</p><p>流量控制是控制发送方的速率，让它不要发送的太快</p><p>流量控制是通过滑动窗口来实现的。滑动窗口使得发送方发送完一个数据之后不必等待 ACK，就可以发送下一报文，接收方可以使用累计确认的方式来应答。tcp 头部中有一个窗口字段，它是告诉发送方自己还有多少缓存区能够容纳数据，所以发送方的窗口是由接收方窗口大小决定的。</p><p>发送方窗口的数据可以发为四个部分，发送已收到确认的数据，发送还没收到确认的数据，还没发送但没有超过发送窗口的数据，还没发送并且超过发送窗口的数据。</p><p>程序是如何表示发送方的四个部分的呢？</p><p>通过三个指针</p><ul><li><code>SND.WND</code> ：表示发送窗口的大小（大小是由接收方指定的）；</li><li><code>SND.UNA</code> （<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，</li><li><code>SND.NXT</code> ：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号<br>流量控制整个过程如下，我们假设应用层都能及时的处理数据：</li><li>假设发送窗口是 200；</li><li>发送方发送了 100 字节的数据，可发送数据的窗口就会剩 100。接收方收到后发送 ACK，发送方收到 ack 后，窗口会向前移动，可发送数据的窗口又变为 200。<br>可实际上发送窗口会受缓存大小的影响：<br>假设服务器很忙，不能及时处理数据，发送方发送了 100 字节数据，服务器只处理 50 字节，那么接收窗口就会变成 150，发送方收到 ack 后，会把发送窗口调整 150；如果发送方又发了 150 字节，接收方又没能处理，接收窗口就变为 0，发送方收到确认后就不能发送数据，窗口关闭。<br>窗口关闭的风险？</li></ul><p>当窗口变为 0 时，发送方会等待接收方是否处理完数据，会等待一个非 0 窗口通知。如果这个通知丢失，就<strong>可能造成死锁</strong>（滑动窗口会出现死锁吗？）。发送方会一直等待一个非 0 窗口通知，接收方则一直等待发送方发送数据。</p><p>为此 TCP 设计了一个持续定时器，当接收方接收到了 0 窗口通知，会开启持续定时器，定时器超时后，会发送窗口探测报文，接收方会汇报自己接收窗口的大小；如果还为 0，则重启定时器</p></li><li><p>拥塞控制</p><p>拥塞控制是防止发送过多数据，造成网络的阻塞，流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p><p>为什么要有拥塞控制？</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大</strong></p><p>拥塞控制拥有窗口的概念，所以发送方发送数据的大小是发送窗口和拥塞窗口的最小值</p><p>拥塞窗口通过拥塞算法来动态的改变拥塞窗口的大小</p><ul><li><p>慢开始</p><p>一开始发送数据时，拥塞窗口为 1，收到确认后，拥塞窗口 + 1，变为 2，当收到第二次发送数据确认后，拥塞窗口 + 2，所以慢开始是一个指数增长的过程。</p></li><li><p>拥塞避免算法</p><p>等到增长到 ssthresh（慢启动阈值）时，改用线性增长，每次拥塞窗口 + 1</p></li><li><p>超时重传</p><p>当发生拥塞时，也就是出现数据没收到，需要重传。慢启动阈值变为拥塞窗口大小，然后拥塞窗口会变为 1，重新开始。</p></li><li><p>快开始</p><p>当发送方连续收到三个连续的 ack 时，可以使用快速重传。快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕</p><p>这时将慢启动阈值设置为拥塞窗口的一半，拥塞窗口设置为慢启动阈值 + 3，+3 是因为收到了 3 个重复 ACK。之后重传数据，如果还是收到相同的 ACK，则每次拥塞窗口加 1，尽快让接收方获得数据。如果收到新的 ACK，则设置拥塞窗口为慢启动阈值。</p></li></ul></li></ul><h2 id="q超时时间怎么设置"><a class="anchor" href="#q超时时间怎么设置">#</a> Q：超时时间怎么设置？</h2><p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p><p>估计往返时间，通常需要采样以下两个：</p><ul><li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li><li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li></ul><h2 id="q糊涂窗口综合症是什么"><a class="anchor" href="#q糊涂窗口综合症是什么">#</a> Q：糊涂窗口综合症是什么？</h2><p>如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。</p><p>到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。每次发送数据量很小，然而每个报文头部都有 40 字节，导致效率不高</p><p>解决办法：</p><p>可以避免接收窗口通告小窗口，当接收窗口小于 min (MSS, 缓存的一半）时，就通知发送方窗口为 0，不让发送方继续发数据</p><p>发送方一般采用 Nagle 算法，思路就是延迟处理，将小数据包囤积成大数据包。如果以下两个条件都不满足就要囤积：一是窗口大小大于 MSS，二是收到之前数据 ACK。</p><p>注意发送开启 Nagle 算法，要先满足避免接收窗口通告小窗口。</p><h2 id="qip协议是什么作用是什么怎么工作的"><a class="anchor" href="#qip协议是什么作用是什么怎么工作的">#</a> Q：IP 协议是什么？作用是什么？怎么工作的？</h2><p>IP 协议属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们在跨网络传播中能够到达正确的目的地。</p><p>目前 IP 协议主要有两种，一种是过去的 IPv4，另一种是较新的 IPv6。</p><p>它是靠 ip 地址工作，I 每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 <strong>IP 地址</strong>作为唯一标识符，每个 IP 地址都是一个字符序列。</p><p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。源 IP 地址发送方设备的 IP 地址，而目的 IP 地址则是接收方设备的地址。网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p><h2 id="q你知道ip地址过滤吗"><a class="anchor" href="#q你知道ip地址过滤吗">#</a> Q：你知道 IP 地址过滤吗？</h2><p><strong>IP 地址过滤（IP Address Filtering）</strong> 简单来说就是限制或阻止特定 IP 地址或 IP 地址范围的访问。</p><p>IP 地址过滤是一种简单的网络安全措施，实际应用中一般会结合其他网络安全措施，如认证、授权、加密等一起使用。单独使用 IP 地址过滤并不能完全保证网络的安全。</p><h2 id="qipv4和ipv6的区别"><a class="anchor" href="#qipv4和ipv6的区别">#</a> Q：IPv4 和 IPv6 的区别？</h2><ul><li>IPv4 是 32 位，IPv6 是 128 位（这也是使用 IPv6 的主要原因，IPv4 能生成的地址不够用）</li><li>IPv6 相对头部作了简化，减少了开销</li><li>IPv6 允许添加不同扩展头，从而实现不同的功能</li><li>IPv6 可以直接生成全局唯一的 IPv6 地址，而无需依赖 DHCP</li></ul><h2 id="qnat的作用怎么工作"><a class="anchor" href="#qnat的作用怎么工作">#</a> Q：NAT 的作用？怎么工作？</h2><p>NAT 的主要是完成私有地址和公有地址之间的转换。比如将局域网下的私有地址转化为互联网中的公有地址。</p><p>NAT 实现局域网内的多个设备通过单一公有 IP 地址访问互联网。NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。</p><p>当局域网中的一个设备发送请求给服务器时，先会生成一个源端口号，NAT 路由器收到会将私有地址转换为一个公有地址，修改源端口号，并维护一条转换记录在 NAT 转换表中。之后发送给服务器。服务器响应报文的目的地址也是这个公有地址，NAT 收到响应报文后，会查 NAT 转换表，发送给对应的主机。</p><h2 id="q什么是arp有什么作用怎么工作的"><a class="anchor" href="#q什么是arp有什么作用怎么工作的">#</a> Q：什么是 ARP? 有什么作用？怎么工作的？</h2><p>ARP 是一个将通过 IP 地址找到设备对应的物理地址的协议。MAC 地址又称物理地址，是网络设备的唯一标识，总共 48 位，存储在网卡。</p><p>在网络中，每个设备都维护了一个<strong> ARP 表</strong>，维护了 mac 地址和 ip 地址的映射关系。如果是在同一个局域网下的话，当查询一个 ip 地址所对应的物理地址，首先会查表，如果没有的话会发送一个查询报文，以<strong>广播</strong>的形式发出，局域网内所有设备都能收到，如果目的地址是自己，就会响应一个报文回去，告诉自己的物理地址。发出查询设备会将映射关系写入到 ARP 表中。</p><p>如果不在同一个局域网的话，首先会去 ARP 表中查询目标路由器的物理地址，目标路由器是指通过目的 ip 地址可以查询到属于哪一个子网的路由器。没查到，会和之前一样广播发送查询报文，目标路由器收到后返回响应报文。收到物理地址后，就把数据发送给路由器，由路由器再转发给目标设备。</p><h2 id="qip欺骗是什么怎么解决"><a class="anchor" href="#qip欺骗是什么怎么解决">#</a> Q：IP 欺骗是什么？怎么解决？</h2><p>IP 欺骗技术就是<strong>伪造</strong>某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够<strong>伪装</strong>另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。</p><p><strong>入口过滤</strong> 是防范欺骗的一种极为常见的防御措施，入口过滤是一种数据包过滤形式，通常在网络边缘的设备上设置，用于检查传入的 IP 数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包。</p><h2 id="qsql注入是什么"><a class="anchor" href="#qsql注入是什么">#</a> Q：SQL 注入是什么？</h2><p><strong>SQL 注入</strong>（SQL Injection）是一种常见的 Web 安全漏洞，形成的主要原因是 web 应用程序在接收相关数据参数时未做好过滤，将其直接带入到数据库中查询，导致攻击者可以拼接执行构造的 SQL 语句。</p><p>解决 SQL 注入问题的方法主要有以下几种：</p><ol><li>输入验证和转义：在将用户输入用作 SQL 查询的一部分之前，对输入进行验证和转义。确保输入符合预期格式，并防止任何可能导致 SQL 注入的特殊字符。</li><li>使用参数化查询：使用参数化查询可以避免直接将用户输入嵌入到 SQL 查询中。参数化查询使用预定义的变量来接收用户输入，并将其传递给数据库引擎，而不是直接将其用作查询的一部分。这样可以防止 SQL 注入攻击。</li><li>限制数据库权限：限制数据库用户的权限，只授予他们执行所需操作所需的最低权限。攻击者可能具有比预期更多的权限，这可能会使攻击更加容易。</li><li>实施输入过滤：在某些情况下，实施输入过滤可以进一步减少 SQL 注入的风险。这可能涉及检查和过滤用户输入中的特殊字符和词汇，以排除可能的恶意输入。</li></ol><h2 id="qudp-flood是什么"><a class="anchor" href="#qudp-flood是什么">#</a> Q：UDP Flood 是什么？</h2><p>UDP Flood 也是一种拒绝服务攻击，将大量的用户数据报协议（UDP）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因 UDP 泛滥而耗尽，从而导致对合法流量的拒绝服务</p><p>用防火墙等设备，设置规则过滤掉无效的 UDP 数据包，只允许合法的 UDP 通信；在防火墙使用自动黑名单机制，将频繁发起 UDP FLOOD 攻击的 IP 地址自动加入黑名单；控制流量；</p><h2 id="qhttp-flood是什么"><a class="anchor" href="#qhttp-flood是什么">#</a> Q：HTTP Flood 是什么？</h2><p>HTTP Flood 攻击，也被称为 CC 攻击（Challenge Collapsar），是一种针对 Web 服务在第七层协议（应用层）发起的分布式拒绝服务（DDoS）攻击。攻击者通过发送大量的 HTTP GET 或 POST 请求来淹没目标服务器，导致服务器无法处理正常流量，进而对来自实际用户的其他请求发生拒绝服务</p><h2 id="qdns-flood是什么"><a class="anchor" href="#qdns-flood是什么">#</a> Q：DNS Flood 是什么？</h2><p>DNS Flood 攻击是一种分布式拒绝服务（DDoS）攻击，攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。通过中断 DNS 解析，DNS Flood 攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力</p><p>使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量。</p><h2 id="qtcp重置攻击"><a class="anchor" href="#qtcp重置攻击">#</a> Q：TCP 重置攻击？</h2><p>在 TCP 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，TCP 就会发送一个重置报文段，从而导致 TCP 连接的快速拆卸</p><h2 id="qddos是什么"><a class="anchor" href="#qddos是什么">#</a> Q：DDOS 是什么？</h2><p>DDos 全名 Distributed Denial of Service，翻译成中文就是<strong>分布式拒绝服务</strong>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用<strong>欺骗和伪装</strong>的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。</p><p>攻击方式很多，比如 <strong>ICMP Flood</strong>、<strong>UDP Flood</strong>、<strong>NTP Flood</strong>、<strong>SYN Flood</strong>、<strong>CC 攻击</strong>、<strong>DNS Query Flood</strong> 等等</p><p>解决：高仿服务器，黑名单，</p><p>Dos 清洗</p><p><strong>DDoS</strong> 清洗会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong> 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。</p><p>CDN 加速</p><p>CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 <strong>DDoS</strong> 攻击，也可以将流量分散到各个节点中，防止源站崩溃</p><h2 id="q中间人攻击是什么"><a class="anchor" href="#q中间人攻击是什么">#</a> Q：中间人攻击是什么？</h2><p>中间人攻击（Man-in-the-Middle Attack，简称 MITM 攻击）是一种会话劫持攻击，攻击者作为中间人，劫持通信双方会话并操纵通信过程，而通信双方并不知情，从而达到窃取信息或冒充访问的目的。这种攻击方式可以针对各种网络协议，如 Wi-Fi、邮件、DNS 和 SSL 等。</p><p>想要避免中间人攻击的方法目前主要有两个：</p><ul><li>客户端不要轻易相信证书：因为这些证书极有可能是中间人。</li><li>App 可以提前预埋证书在本地：意思是我们本地提前有一些证书，这样其他证书就不能再起作用了</li></ul><h2 id="q如果建立了连接客户端突然宕机怎么办"><a class="anchor" href="#q如果建立了连接客户端突然宕机怎么办">#</a> Q：如果建立了连接，客户端突然宕机怎么办？</h2><p>发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 ESTABLISH 状态，占用着系统资源。</p><p>TCP 有个保活机制</p><ul><li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端，对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>第二种，对端主机宕机并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</li><li>第三种，是对端主机宕机（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong></li></ul><p>或者在应用层实现一个心跳机制，指定 HTTP 长连接的超时时间</p><h2 id="q如果已经建立了连接但是服务端的进程崩溃会发生什么"><a class="anchor" href="#q如果已经建立了连接但是服务端的进程崩溃会发生什么">#</a> Q：如果已经建立了连接，但是服务端的进程崩溃会发生什么？</h2><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p><h2 id="q针对tcp的socket编程是怎样的"><a class="anchor" href="#q针对tcp的socket编程是怎样的">#</a> Q：针对 TCP 的 Socket 编程是怎样的？</h2><p><img data-src="image/image_vY3YzQqmQv.png" alt=""></p><ul><li>服务端和客户端初始化 <code>socket</code> ，得到文件描述符；</li><li>服务端调用 <code>bind</code> ，将 socket 绑定在指定的 IP 地址和端口；</li><li>服务端调用 <code>listen</code> ，进行监听；</li><li>服务端调用 <code>accept</code> ，等待客户端连接；</li><li>客户端调用 <code>connect</code> ，向服务端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code> ，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code> ，待处理完数据后，服务端调用 <code>close</code> ，表示连接关闭。</li></ul><p>监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><h2 id="qlisten-时候参数-backlog-的意义"><a class="anchor" href="#qlisten-时候参数-backlog-的意义">#</a> Q：listen 时候参数 backlog 的意义？</h2><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span> <span class="params">(<span class="type">int</span> socketfd, <span class="type">int</span> backlog)</span></span><br></pre></td></tr></table></figure><p></p><p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p><p><strong>但是上限值是内核参数 somaxconn 的大小，也就说 accpet 队列长度 = min (backlog, somaxconn)。</strong></p><h2 id="qaccept-发生在三次握手的哪一步"><a class="anchor" href="#qaccept-发生在三次握手的哪一步">#</a> Q：accept 发生在三次握手的哪一步？</h2><ul><li>客户端的协议栈向服务端发送了 SYN 包，并告诉服务端当前发送序列号 client_isn，客户端进入 SYN_SENT 状态；</li><li>服务端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务端也发送一个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务端进入 SYN_RCVD 状态；</li><li>客户端协议栈收到 ACK 之后，使得应用程序从 <code>connect</code> 调用返回，表示客户端到服务端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务端的 SYN 包进行应答，应答数据为 server_isn+1；</li><li>ACK 应答包到达服务端后，服务端的 TCP 连接进入 ESTABLISHED 状态，同时服务端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务端到客户端的单向连接也建立成功。至此，客户端与服务端两个方向的连接都建立成功。</li></ul><p>从上面的描述过程，我们可以得知<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后</strong></p><h2 id="q客户端调用-close-了连接是断开的流程是什么"><a class="anchor" href="#q客户端调用-close-了连接是断开的流程是什么">#</a> Q：客户端调用 close 了，连接是断开的流程是什么？</h2><ul><li>客户端调用 <code>close</code> ，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li><li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</li><li>接着，当处理完数据后，自然就会读到 <code>EOF</code> ，于是也调用 <code>close</code> 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；</li><li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li><li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</li><li>客户端经过 <code>2MSL</code> 时间之后，也进入 CLOSE 状态；</li></ul><h2 id="q如何优化tcp"><a class="anchor" href="#q如何优化tcp">#</a> Q：如何优化 TCP?</h2><p>可以从 TCP 握手，挥手，传输数据方面来优化</p><ul><li><p>TCP 握手</p><ul><li><p>从客户端角度来说</p><p>当客户端发送请求连接时，首先会发送 SYN 报文，如果客户端长时间没有收到 SYN+ACK 报文，则会重发 SYN 包，<strong>重发的次数由 tcp_syn_retries 参数控制</strong>，<strong>每次重发超时的时间是上一次的 2 倍</strong>。超过指定次数就会停止 TCP 三次握手。所以我们可以根据网络情况和服务器的繁忙状态调整重发的次数</p></li><li><p>从服务器来说</p><p>服务器收到 syn 报文，会把连接放入到半连接队列，之后发送 syn+ack 报文。当半连接队列满了，会拒绝请求。所以可以根据情况调整队列的大小。当然你可以<strong>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接</strong>。它是通过计算一个值放入到 syn+ack 报文中，等收到客户端的回复报文时，比较这个值是否一致</p><p>发送 syn+ack 之后，如果长时间没有客户端的 ack 报文，就会触发超时重传，和客户端一样，可以根据环境调整重传的次数</p><p>等到服务器收到客户端的 ack 后，连接建立成功。会把连接从半连接队列取出，放入到 accept 队列。（等待进程调用 accept 函数将连接从队列取出）如过队列满了，会导致建立好的连接废弃掉。可以适当调整 accept 队列的长度。</p></li><li><p>绕过三次握手</p><p>TCP Fast Open 功能（通过对 cookie 的校验）可以在第二次连接时绕过三次握手，第一次建立连接时，存储 cookie，第二次连接时，第一次请求客户端发送 SYN 报文，该报文包含「数据」和 cookie, 服务器收到后校验 cookie，校验通过，就可以回复确认，并发送数据。</p></li></ul></li><li><p>TCP 四次挥手</p><ul><li><p>主动方的优化</p><p>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 <code>tcp_orphan_retries</code> 参数决定。</p><p>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源， <code>tcp_max_tw_buckets</code> 定义了最大数量，超过时连接也会直接释放。</p><p>当 TIME_WAIT 状态过多时，还可以通过设置 <code>tcp_tw_reuse</code> 和 <code>tcp_timestamps</code> 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。</p></li><li><p>被动方优化</p><p>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</p><p>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 <code>tcp_orphan_retries</code> 参数的控制下重发 FIN 报文。</p></li></ul></li><li><p>传输数据</p><p>tcp 是通过滑动窗口调节发送数据，但默认的滑动窗口最大值只有 64 KB，要想提升发送速度必须提升滑动窗口的上限，在 Linux 下是通过设置 <code>tcp_window_scaling</code> 为 1 做到的，此时最大值可高达 1GB</p><p>但是发送窗口的上限取决于内核缓冲区的大小，因为发送数据后，需要把数据放入到缓冲区，防止接收方没有收到数据，用来重发。发送缓冲区的大小一般可以设置为时延带宽积（带宽 * RTT)。</p></li></ul><h2 id="q如何理解tcp是面向字节流的"><a class="anchor" href="#q如何理解tcp是面向字节流的">#</a> Q：如何理解 TCP 是面向字节流的？</h2><p>之所以会说 TCP 是面向字节流的协议，UDP 是面向报文的协议，是因为操作系统对 TCP 和 UDP 协议的<strong>发送方的机制不同</strong>。</p><p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息</p><p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输，这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的。正因为这样，所以 TCP 是面向字节流的协议</p><h2 id="q粘包问题是什么"><a class="anchor" href="#q粘包问题是什么">#</a> Q：粘包问题是什么？</h2><p>当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题。</p><p>如何解决？</p><p>1、固定长度的消息<br>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。<br>但是这种方式灵活性不高，实际中很少用。</p><p>2、特殊字符作为边界<br>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息<br>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据</p><p>3、自定义消息结构</p><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p><p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p><h2 id="qsyn报文什么时候会被丢弃"><a class="anchor" href="#qsyn报文什么时候会被丢弃">#</a> Q：SYN 报文什么时候会被丢弃？</h2><ul><li><p>开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃</p><p>我们知道 tcp 四次挥手过程中，主动发起方最后会进入到 time_wait 状态，如果客户端的 time_wait 状态过多，会占用过多的端口号，会有端口用尽的风险。这时我们可以开启 tcp_tw_recycle 参数，对处于 time_wait 状态的端口进行重用。</p><p>要使这个配置项生效，首先要开启 TCP 的时间戳选项，开启时间戳后，PAWS 机制会自动开启，它的作用是防止 TCP 包中的序列号发生绕回。PAWS 要求连接双方维护最近一次收到的数据包的时间戳。<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p><p>开启了 recycle 和 timestamps 选项，就会开启一种叫 per-host 的 PAWS 机制。<strong>per-host 是对「对端 IP 做 PAWS 检查」</strong>。当客户端 A 通过 NAT 网关和服务器建立 TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，<strong>客户端 B 也通过 NAT 网关和服务器建立 TCP 连接，注意客户端 A 和 客户端 B 因为经过相同的 NAT 网关，所以是用相同的 IP 地址与服务端建立 TCP 连接，如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小（ timestamp 是根据客户端各自的 CPU tick 得出的值。），那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包</strong></p></li><li><p>半连接队列满了</p></li><li><p>全连接队列满了</p></li></ul><h2 id="q已建立连接的tcp收到syn会发生什么"><a class="anchor" href="#q已建立连接的tcp收到syn会发生什么">#</a> Q：已建立连接的 TCP，收到 SYN 会发生什么？</h2><p>当客户端与服务器建立了连接，客户端突然断线，重连之后，重新发送了 syn</p><ul><li><p>端口不一样</p><p>会认为是新的连接，重新进行三次握手</p><p>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。</p><p>如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</p></li><li><p>端口一样</p><p><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。</strong></p><p><strong>接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。</strong></p></li></ul><h2 id="q如何关闭一个tcp连接"><a class="anchor" href="#q如何关闭一个tcp连接">#</a> Q：如何关闭一个 TCP 连接？</h2><p>可以伪造一个能关闭 TCP 连接的 RST 报文，必须同时满足「四元组相同」和「序列号是对方期望的」这两个条件。</p><p>这两种工具都是通过伪造 RST 报文来关闭 TCP 连接的，但是它们获取「对方下一次期望收到的序列号的方式是不同的，也正因此，造就了这两个工具的应用场景有区别。</p><ul><li>tcpkill 工具只能用来关闭活跃的 TCP 连接，无法关闭非活跃的 TCP 连接，因为 tcpkill 工具是等双方进行 TCP 通信后，才去获取正确的序列号，如果这条 TCP 连接一直没有任何数据传输，则就永远获取不到正确的序列号。</li><li>killcx 工具可以用来关闭活跃和非活跃的 TCP 连接，因为 killcx 工具是主动发送 SYN 报文，这时对方就会回复 Challenge ACK ，然后 killcx 工具就能从这个 ACK 获取到正确的序列号。</li></ul><h2 id="q在第二次挥手和第三次挥手之间发送的数据由于网络阻塞延迟了导致第三次握手的fin先到达"><a class="anchor" href="#q在第二次挥手和第三次挥手之间发送的数据由于网络阻塞延迟了导致第三次握手的fin先到达">#</a> Q：在第二次挥手和第三次挥手之间，发送的数据由于网络阻塞延迟了，导致第三次握手的 FIN 先到达？</h2><p>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。</p><p>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</p><h2 id="q处于time_wait状态的服务器收到syn会怎么样"><a class="anchor" href="#q处于time_wait状态的服务器收到syn会怎么样">#</a> Q：处于 time_wait 状态的服务器，收到 SYN 会怎么样？</h2><p>关键是要看 SYN 的「序列号和时间戳」是否合法。</p><ul><li><strong>合法 SYN</strong>：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。（如果开启时间戳）</li></ul><p>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程</strong>。</p><p>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会<strong>再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端</strong>。</p><h2 id="q在-time_wait-状态收到-rst-会断开连接吗"><a class="anchor" href="#q在-time_wait-状态收到-rst-会断开连接吗">#</a> Q：在 TIME_WAIT 状态，收到 RST 会断开连接吗？</h2><p>会不会断开，关键看 <code>net.ipv4.tcp_rfc1337</code> 这个内核参数（默认情况是为 0）：</p><ul><li>如果这个参数设置为 0， 收到 RST 报文会提前结束 TIME_WAIT 状态，释放连接。</li><li>如果这个参数设置为 1， 就会丢掉 RST 报文。</li></ul><h2 id="qtcp连接一端断电和进程崩溃有什么区别"><a class="anchor" href="#qtcp连接一端断电和进程崩溃有什么区别">#</a> Q：TCP 连接，一端断电和进程崩溃有什么区别？</h2><ol><li><p>如果有保活机制，开启 TCP keepalive 后，一段时间如果没有活动，会发送一个探测报文，如果对端是正常的，会发送保活报文。如果几次没收到回复，会认为连接已经死亡。</p></li><li><p>在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发生什么？</p><p>客户端主机崩溃了，服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程</p><p>TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p></li><li><p>有数据传输的场景</p><ul><li><p>客户端宕机后，立即重启</p><ul><li>如果客户端主机上<strong>没有</strong>进程绑定该 TCP 报文的目标端口号，那么客户端内核就会<strong>回复 RST 报文，重置该 TCP 连接</strong>；</li><li>如果客户端主机上<strong>有</strong>进程绑定该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。<br>所以，<strong>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接</strong></li></ul></li><li><p>客户端宕机后，一直没有重启</p><p>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开</p></li></ul></li></ol><h2 id="q拔掉网线后-原本的-tcp-连接还存在吗"><a class="anchor" href="#q拔掉网线后-原本的-tcp-连接还存在吗">#</a> Q：拔掉网线后， 原本的 TCP 连接还存在吗？</h2><p>客户端拔掉网线后，并不会直接影响 TCP 连接状态。所以，拔掉网线后，TCP 连接是否还会存在，关键要看拔掉网线之后，有没有进行数据传输。</p><ul><li>如果有数据传输，客户端没收到会触发超时重传，超过一定次数，服务器就会断开连接。如果在重传的过程中插回了网线，客户端还是可以收到数据，跟没发生什么事一样。</li><li>如果没有数据传输，可以看是否开启了保活机制。如果客户端一直不插回网线，TCP keepalive 机制会探测到对方的 TCP 连接没有存活，于是就会断开 TCP 连接。而如果在 TCP 探测期间，客户端插回了网线，那么双方原本的 TCP 连接还是能正常存在。</li><li>如果没有数据传输，也没有保活机制，那么在客户端拔掉网线后，如果客户端一直不插回网线，那么客户端和服务端的 TCP 连接状态将会一直保持存在。</li></ul><h2 id="q为什么-tcp_tw_reuse-默认是关闭的"><a class="anchor" href="#q为什么-tcp_tw_reuse-默认是关闭的">#</a> Q：为什么 tcp_tw_reuse 默认是关闭的？</h2><p>因为开启 reuse 会有两个问题</p><ul><li><p>历史 RST 报文可能会终止后面相同四元组的连接</p><p>防回绕序列号函数的源码中，对于 <strong>RST 报文的时间戳即使过期了，只要 RST 报文的序列号在对方的接收窗口内，也是能被接受的</strong>。这就可能导致历史 RST 报文可能会终止后面相同四元组的连接</p><p>假设这样一个场景：</p><ul><li>客户端向一个还没有被服务端监听的端口发起了 HTTP 请求，接着服务端就会回 RST 报文给对方，很可惜的是 <strong>RST 报文被网络阻塞了</strong>。</li><li>由于客户端迟迟没有收到 TCP 第二次握手，于是重发了 SYN 包，与此同时服务端已经开启了服务，监听了对应的端口。于是接下来，客户端和服务端就进行了 TCP 三次握手、数据传输（HTTP 应答 - 响应）、四次挥手。</li><li>因为<strong>客户端开启了 tcp_tw_reuse，于是快速复用 TIME_WAIT 状态的端口，又与服务端建立了一个与刚才相同的四元组的连接</strong>。</li><li>接着，<strong>前面被网络延迟 RST 报文这时抵达了客户端，而且 RST 报文的序列号在客户端的接收窗口内，由于防回绕序列号算法不会防止过期的 RST，所以 RST 报文会被客户端接受了，于是客户端的连接就断开</strong><br>为什么要接收过期的 RST?<br>因为正常情况下，不会有这种历史的 RST，因为经过 time_wait 状态，历史的报文会消失</li></ul></li><li><p>开启 tcp_tw_reuse 来快速复用 TIME_WAIT 状态的连接，如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，处于 syn_sent 状态的客户端收到服务端重传第三次挥手报文，则会回 RST 给服务端</p><p>如果 TIME_WAIT 状态被快速复用后，刚好第四次挥手的 ACK 报文丢失了，那客户端复用 TIME_WAIT 状态后发送的 SYN 报文被处于 last_ack 状态的服务端收到了会发生什么呢？</p><p>处于 last_ack 状态的服务端收到了 SYN 报文后，会回复确认号与服务端上一次发送 ACK 报文一样的 ACK 报文，这个 ACK 报文称为 <span class="exturl" data-url="aHR0cHM6Ly94aWFvbGluY29kaW5nLmNvbS9uZXR3b3JrLzNfdGNwL2NoYWxsZW5nZV9hY2suaHRtbA==">Challenge ACK (opens new window)</span>，并不是确认收到 SYN 报文。</p><p>处于 syn_sent 状态的客户端收到服务端的 <span class="exturl" data-url="aHR0cHM6Ly94aWFvbGluY29kaW5nLmNvbS9uZXR3b3JrLzNfdGNwL2NoYWxsZW5nZV9hY2suaHRtbA==">Challenge ACK (opens new window)</span> 后，发现不是自己期望收到的确认号，于是就会回复 RST 报文，服务端收到后，就会断开连接。</p></li></ul><h2 id="q-https-中-tls-和-tcp-能同时握手吗"><a class="anchor" href="#q-https-中-tls-和-tcp-能同时握手吗">#</a> Q： HTTPS 中 TLS 和 TCP 能同时握手吗？</h2><p>客户端和服务端同时支持 TCP Fast Open 功能的情况下，<strong>在第二次以后到通信过程中，客户端可以绕过三次握手直接发送数据，而且服务端也不需要等收到第三次握手后才发送数据。</strong>（它是在第二次发送 ack 之后就可以发送数据，不需要等待第三次握手）</p><p>如果 HTTPS 的 TLS 版本是 1.3，那么 TLS 过程只需要 1-RTT。（第三次握手就可以携带数据）</p><p><strong>因此如果「TCP Fast Open + TLSv1.3」情况下，在第二次以后的通信过程中，TLS 和 TCP 的握手过程是可以同时进行的。</strong></p><p><strong>如果基于 TCP Fast Open 场景下的 TLSv1.3 0-RTT 会话恢复过程，不仅 TLS 和 TCP 的握手过程是可以同时进行的，而且 HTTP 请求也可以在这期间内一同完成</strong></p><h2 id="qtcp-keepalive-和-http-keep-alive-是一个东西吗"><a class="anchor" href="#qtcp-keepalive-和-http-keep-alive-是一个东西吗">#</a> Q：TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</h2><p>HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求 / 应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销。</p><p>TCP 的 Keepalive 也叫 TCP 保活机制，该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。</p><h2 id="qtcp有哪些缺点"><a class="anchor" href="#qtcp有哪些缺点">#</a> Q：TCP 有哪些缺点？</h2><ul><li><p>升级 TCP 的工作很困难；</p><p>TCP 是由内核实现的，TCP 要想升级，内核就要升级，而内核升级是件很麻烦的事，涉及到底层软件，运行库的升级</p></li><li><p>TCP 建立连接的延迟；</p><p>基于 TCP 实现的应用协议，都是需要先建立三次握手才能进行数据传输，存在一定延迟</p><p>不过 tcp-fast-open 可以在第二次连接减少延迟</p><ul><li>在第一次建立连接的时候，服务端在第二次握手产生一个 <code>Cookie</code> （已加密）并通过 SYN、ACK 包一起发给客户端，于是客户端就会缓存这个 <code>Cookie</code> ，所以第一次发起 HTTP Get 请求的时候，还是需要 2 个 RTT 的时延；</li><li>在下次请求的时候，客户端在 SYN 包带上 <code>Cookie</code> 发给服务端，就提前可以跳过三次握手的过程，因为 <code>Cookie</code> 中维护了一些信息，服务端可以从 <code>Cookie</code> 获取 TCP 相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；<br><img data-src="image/image_oyepl-ZN5c.png" alt=""></li></ul></li><li><p>TCP 存在队头阻塞问题；</p><p>TCP 是字节流协议，<strong>TCP 层必须保证收到的字节数据是完整且有序的</strong>，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据</p></li><li><p>网络迁移需要重新建立 TCP 连接；</p><p><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong></p></li></ul><h2 id="q如何基于-udp-协议实现可靠传输"><a class="anchor" href="#q如何基于-udp-协议实现可靠传输">#</a> Q：如何基于 UDP 协议实现可靠传输？</h2><p>QUIC 协议就是基于 UDP 之上实现可靠传输</p><ul><li><p>QUCI 是如何保证可靠传输？</p><p>HTTP/3 例子，在 UDP 报文头部与 HTTP 消息之间，共有 3 层头部。</p><ul><li><p>Packet Header</p><p>首次建立连接时和日常传输数据时使用的 Header 是不同的。首次建立连接需要指明源连接 ID，目标连接 ID，在日常传输数据就不需要再指明源连接 ID。在传输数据的 head 中， <code>Packet Number</code> 是每个报文独一无二的编号，它是<strong>严格递增</strong>的，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。</p><p>这样设计有两个好处：</p><ol><li><p>TCP 在重传报文时的序列号和原始报文的序列号是一样的，也正是由于这个特性，引入了 TCP 重传的歧义问题。TCP 发生超时重传后，客户端发起重传，然后接收到了服务端确认 ACK 。由于客户端原始报文和重传报文序列号都是一样的，那么服务端针对这两个报文回复的都是相同的 ACK。这样的话，客户端就无法判断出是「原始报文的响应」还是「重传报文的响应」，这样在计算 RTT（往返时间） 时会不精准。RTO （超时时间）是基于 RTT 来计算的，那么如果 RTT 计算不精准，那么 RTO （超时时间）也会不精确，这样可能导致重传的概率事件增大。</p><p>QUIC 报文中的 Pakcet Number 是严格递增的， 即使是重传报文，它的 Pakcet Number 也是递增的，这样就能更加精确计算出报文的 RTT。</p></li><li><p><strong>QUIC 使用的 Packet Number 单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC 支持乱序确认，当数据包 Packet N 丢失后，只要有新的已接收数据包确认，当前窗口就会继续向右滑动</strong>，而 TCP 必须是顺序确认的，丢包时会导致窗口不滑动；</p></li></ol></li><li><p>Frame Header 这一层，<strong>通过 Stream ID + Offset 字段信息实现数据的有序性</strong>，通过比较两个数据包的 Stream ID 与 Stream Offset ，如果都是一致，就说明这两个数据包的内容一致<br>总的来说，<strong>QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息，可以支持乱序确认而不影响数据包的正确组装</strong>，摆脱了 TCP 必须按顺序确认应答 ACK 的限制，解决了 TCP 因某个数据包重传而阻塞后续所有待发送数据包的问题。</p></li></ul></li><li><p>QUIC 是如何解决头部阻塞的？</p><p>** HTTP/2 多个 Stream 请求都是在一条 TCP 连接上传输，这意味着多个 Stream 共用同一个 TCP 滑动窗口，那么当发生数据丢失，滑动窗口是无法往前移动的，此时就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞 **​</p><p><strong>QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是相互独立的，各自控制的滑动窗口</strong>。</p></li><li><p>QUIC 是如何做流量控制的？</p><p>QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：</p><ul><li><p><strong>Stream 级别的流量控制</strong>：Stream 可以认为就是一条 HTTP 请求，每个 Stream 都有独立的滑动窗口，所以每个 Stream 都可以做流量控制，防止单个 Stream 消耗连接（Connection）的全部接收缓冲。</p><p>TCP 的接收窗口只有在前面所有的 Segment 都接收的情况下才会移动左边界，当在前面还有字节未接收但收到后面字节的情况下，窗口也不会移动。<br>QUIC 的接收窗口的左边界滑动条件取决于接收到的最大偏移字节数。</p><p>当已被上层接收的数据超过最大接收窗口的一半后，最大接收窗口向右移动，接收窗口的右边界也向右扩展，同时给对端发送「窗口更新帧」，当发送方收到接收方的窗口更新帧后，发送窗口的右边界也会往右扩展，以此达到窗口滑动的效果。</p></li><li><p><strong>Connection 流量控制</strong>：限制连接中所有 Stream 相加起来的总字节数，防止发送方超过连接的缓冲容量。</p><p>而对于 Connection 级别的流量窗口，其接收窗口大小就是各个 Stream 接收窗口大小之和</p></li></ul></li><li><p>QUIC 对拥塞控制的改善？</p><p>QUIC 协议当前默认使用了 TCP 的 Cubic 拥塞控制算法（我们熟知的慢开始、拥塞避免、快重传、快恢复策略），QUIC 是处于应用层的，<strong>可以针对不同的应用设置不同的拥塞控制算法</strong>，这样灵活性就很高了</p></li><li><p>QUIC 实现更快的连接</p><p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP/3 的 QUIC 协议并不是与 TLS 分层，而是<strong> QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的 “记录”，再加上 QUIC 使用的是 TLS1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</strong></p></li><li><p>QUIC 实现快速迁移</p><p><strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</strong>。</p><p>而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>QUIC 协议没有用四元组的方式来 “绑定” 连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以 “无缝” 地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能</p></li></ul><h2 id="q服务端没有-listen客户端发起连接建立会发生什么"><a class="anchor" href="#q服务端没有-listen客户端发起连接建立会发生什么">#</a> Q：服务端没有 listen，客户端发起连接建立，会发生什么？</h2><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</strong>（RST 用于终止 TCP 连接或指示连接出现错误)</p><h2 id="q没有-listen能建立-tcp-连接吗"><a class="anchor" href="#q没有-listen能建立-tcp-连接吗">#</a> Q：没有 listen，能建立 TCP 连接吗？</h2><p>是可以的，客户端是可以自己连自己的形成连接（TCP 自连接），也可以两个客户端同时向对方发出请求建立连接（TCP 同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有 listen，就能建立连接。</p><p>形成连接，前提是你得有个地方存放着，方便握手的时候能根据 IP + 端口等信息找到对应的 socket。</p><p>TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中 (客户端没有半连接队列），然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接</p><h2 id="q为什么全连接队列是个链表而半连接队列是个哈希表"><a class="anchor" href="#q为什么全连接队列是个链表而半连接队列是个哈希表">#</a> Q：为什么<strong>全连接队列是个链表</strong>，而<strong>半连接队列是个哈希表？</strong></h2><p><strong>全连接里队列，</strong> 它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为 <code>O(1)</code> 。</p><p>而<strong>半连接队列</strong>却不太一样，因为队列里的都是不完整的连接，等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应 IP 端口的连接取出，<strong>如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是 O (n)。</strong></p><p>而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到 <code>O(1)</code> 了。</p><p>因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。</p><h2 id="q没有accept能建立连接吗"><a class="anchor" href="#q没有accept能建立连接吗">#</a> Q：没有 accept 能建立连接吗？</h2><p>可以， <code>accept方法</code> 只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎<strong>毫无关系</strong></p><h2 id="qsyn-cookies为什么不直接取代半连接队列"><a class="anchor" href="#qsyn-cookies为什么不直接取代半连接队列">#</a> Q：syn cookies 为什么不直接取代半连接队列？</h2><p>凡事皆有利弊， <code>cookies</code> 方案虽然能防 <strong>SYN Flood 攻击</strong>，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</p><p>另外，编码解码 <code>cookies</code> ，都是比较<strong>耗 CPU</strong> 的，利用这一点，如果此时攻击者构造大量的<strong>第三次握手包（ACK 包）</strong>，同时带上各种瞎编的 <code>cookies</code> 信息，服务端收到 <code>ACK包</code> 后<strong>以为是正经 cookies</strong>，憨憨地跑去解码（<strong>耗 CPU</strong>），最后发现不是正经数据包后才丢弃。</p><p>这种通过构造大量 <code>ACK包</code> 去消耗服务端资源的攻击，叫<strong> ACK 攻击</strong>，受到攻击的服务器可能会因为<strong> CPU 资源耗尽</strong>导致没能响应正经请求。</p><h2 id="q消息从聊天框发出到对方收到是怎么传输的"><a class="anchor" href="#q消息从聊天框发出到对方收到是怎么传输的">#</a> Q：消息从聊天框发出到对方收到，是怎么传输的？</h2><p>一个数据包，从聊天框里发出，消息会从<strong>聊天软件</strong>所在的<strong>用户空间</strong>拷贝到<strong>内核空间</strong>的<strong>发送缓冲区（send buffer）</strong>，数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过 RingBuffer 发到物理层的网卡</strong>。数据就这样顺着<strong>网卡</strong>发到了<strong>纷繁复杂</strong>的网络世界里。这里头数据会经过 n 多个<strong>路由器和交换机</strong>之间的跳转，最后到达<strong>目的机器的网卡</strong>处。</p><p>此时目的机器的网卡会通知<strong> DMA</strong> 将数据包信息放到 <code>RingBuffer</code> 中，再触发一个<strong>硬中断</strong>给 <code>CPU</code> ， <code>CPU</code> 触发<strong>软中断</strong>让 <code>ksoftirqd</code> 去 <code>RingBuffer</code> 收包，于是一个数据包就这样顺着<strong>物理层，数据链路层，网络层，传输层</strong>，最后从内核空间拷贝到用户空间里的<strong>聊天软件</strong>里。</p><p><img data-src="image/image_GXI4lWoHWT.png" alt=""></p><h2 id="q什么场景会丢包"><a class="anchor" href="#q什么场景会丢包">#</a> Q：什么场景会丢包？</h2><ul><li><p>建立连接时丢包</p><p>在服务端，第一次握手之后，会先建立个<strong>半连接</strong>，然后再发出第二次握手。这时候需要有个地方可以<strong>暂存</strong>这些半连接。这个地方就叫<strong>半连接队列</strong>。</p><p>如果之后第三次握手来了，半连接就会升级为全连接，然后暂存到另外一个叫<strong>全连接队列</strong>的地方，坐等程序执行 <code>accept()</code> 方法将其取走使用。</p><p>如果队列满了，新来的包就会丢弃</p></li><li><p>流量控制丢包</p><p>应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的<strong> qdisc</strong>(<strong>Q</strong>ueueing <strong>Disc</strong>iplines，排队规则)，这也是我们常说的<strong>流量控制</strong>机制。发送数据过快，流控队列长度 <code>txqueuelen</code> 又不够大时，就容易出现<strong>丢包</strong>现象。</p></li><li><p>RingBuffer 过小导致丢包</p><p>在接收数据时，会将数据暂存到 <code>RingBuffer</code> 接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个<strong>缓冲区过小</strong>，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生<strong>丢包</strong></p></li><li><p>网卡性能</p><p>网卡传输速度有限，当网络传输速度过大，达到网卡上限时，就会发生丢包。这种情况一般常见于压测场景。</p></li><li><p>两端之间网络丢包</p><p>两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的。</p><p>使用 ping 命令查看<strong>机器和目的机器之间有没有丢包。</strong></p><p>mtr 命令可以查看到你的机器和目的机器之间的每个节点的丢包情况。</p><p>需要注意的是，中间有一些是 host 是 <code>???</code> ，那个是因为<strong> mtr 默认用的是 ICMP 包</strong>，有些节点限制了<strong> ICMP 包</strong>，导致不能正常展示。</p><p>我们可以在 mtr 命令里加个 <code>-u</code> ，也就是使用<strong> udp 包</strong>，就能看到部分？？？对应的 IP</p><p><img data-src="image/image_ju_P0ebrXD.png" alt=""></p></li></ul><h2 id="q丢包了怎么办"><a class="anchor" href="#q丢包了怎么办">#</a> Q：丢包了怎么办？</h2><p>建立了 TCP 连接的两端，发送端在发出数据后会等待接收端回复 <code>ack包</code> ， <code>ack包</code> 的目的是为了告诉对方自己确实收到了数据，但如果中间链路发生了丢包，那发送端会迟迟收不到确认 ack，于是就会进行<strong>重传</strong>。以此来保证每个数据包都确确实实到达了接收端。</p><p>假设现在网断了，我们还用聊天软件发消息，聊天软件会使用 TCP 不断尝试重传数据，<strong>如果重传期间网络恢复了</strong>，那数据就能正常发过去。但如果多次重试直到超时都还是失败，这时候你将收获一个<strong>红色感叹号</strong>。</p><h2 id="q用了tcp协议就一定不会丢包吗"><a class="anchor" href="#q用了tcp协议就一定不会丢包吗">#</a> Q：用了 TCP 协议就一定不会丢包吗？</h2><p>我们知道 TCP 位于<strong>传输层</strong>，在它的上面还有各种<strong>应用层协议</strong>。</p><p>TCP 保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP 只保证数据从 A 机器的传输层可靠地发到 B 机器的传输层。</strong></p><p>至于数据到了接收端的传输层之后，能不能保证到应用层，TCP 并不管。</p><p>假设现在，我们输入一条消息，从聊天框发出，走到<strong>传输层 TCP 协议的发送缓冲区</strong>，不管中间有没有丢包，最后通过重传都保证发到了对方的<strong>传输层 TCP 接收缓冲区</strong>，此时接收端回复了一个 <code>ack</code> ，发送端收到这个 <code>ack</code> 后就会将自己<strong>发送缓冲区</strong>里的消息给扔掉。到这里 TCP 的任务就结束了。</p><p>TCP 任务是结束了，但聊天软件的任务没结束。</p><p><strong>聊天软件还需要将数据从 TCP 的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p><p>发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><p>于是乎，<strong>消息就丢了。</strong></p><p>怎么解决？</p><p>服务器记录了我们最近发过什么数据，假设<strong>每条消息都有个 id</strong>，服务器和聊天软件每次都拿<strong>最新消息的 id</strong> 进行对比，就能知道两端消息是否一致，就像<strong>对账</strong>一样。</p><p>对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p><p>如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p><p>那么问题叒来了，<strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><p>主要有三个原因。</p><ul><li>第一，如果是两端通信，你聊天软件里有 <code>1000个</code> 好友，你就得建立 <code>1000个</code> 连接。但如果引入服务端，你只需要跟服务器建立 <code>1个</code> 连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</li><li>第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</li><li>第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</li></ul><h2 id="qclose和shutdown的区别"><a class="anchor" href="#qclose和shutdown的区别">#</a> Q：close 和 shutdown 的区别？</h2><ul><li>close 函数，<strong>同时 socket 关闭发送方向和读取方向</strong>，也就是 socket 不再有发送和接收数据的能力。如果有多进程 / 多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</li><li>shutdown 函数，可以指定 socket <strong>只关闭发送方向而不关闭读取方向</strong>，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程 / 多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</li></ul><div class="tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"><i class="ic i-tag"></i> 计算机网络</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-03-07 16:38:45" itemprop="dateModified" datetime="2025-03-07T16:38:45+08:00">2025-03-07</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Wu Zhian 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Wu Zhian 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Wu Zhian 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Wu Zhian <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://zhian-wu.github.io/cs/job/Bagu/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">https://zhian-wu.github.io/cs/job/Bagu/计算机网络/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"></div><div class="item right"><a href="/cs/job/Bagu/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicis081o9j20zk0m8dmr.jpg" title="黑马点评常见问题"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>黑马点评常见问题</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%93%AA%E5%87%A0%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">Q：计算机网络分哪几层？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">Q：为什么要分层？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E9%83%BD%E7%94%A8%E5%9B%9B%E5%B1%82%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Q：为什么现在都用四层而不是七层模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qip%E5%9C%B0%E5%9D%80%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-number">4.</span> <span class="toc-text">Q：IP 地址分成几个部分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%AD%97%E7%BD%91%E6%8E%A9%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">Q：字网掩码有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">6.</span> <span class="toc-text">Q：从输入 URL 到网页显示的过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qip%E5%9C%B0%E5%9D%80%E5%92%8Cmac%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">Q：IP 地址和 MAC 地址的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qlinux%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84"><span class="toc-number">8.</span> <span class="toc-text">Q：Linux 是如何发数据包的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8C%85%E6%B6%89%E5%8F%8A%E5%87%A0%E6%AC%A1%E5%A4%8D%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">Q：发送数据包涉及几次复制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%BB%80%E4%B9%88%E6%98%AFhttp"><span class="toc-number">10.</span> <span class="toc-text">Q：什么是 HTTP？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">11.</span> <span class="toc-text">Q：HTTP 状态码有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">Q：HTTP 协议报文格式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E5%86%99"><span class="toc-number">13.</span> <span class="toc-text">Q：HTTP 请求头常见字段有哪写？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">14.</span> <span class="toc-text">Q：HTTP 如何解决粘包问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">15.</span> <span class="toc-text">Q：HTTP 缓存技术有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">Q：HTTP 和 HTTPS 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp10-%E5%92%8Chttp11%E5%8C%BA%E5%88%ABhttp11%E4%BC%98%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">Q：HTTP&#x2F;1.0 和 HTTP&#x2F;1.1 区别？（HTTP&#x2F;1.1 优点）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp11-%E5%92%8Chttp20%E5%8C%BA%E5%88%ABhttp20%E7%9A%84%E4%BC%98%E7%82%B9http11%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">Q：HTTP&#x2F;1.1 和 HTTP&#x2F;2.0 区别？（HTTP&#x2F;2.0 的优点，HTTP&#x2F;1.1 的缺点）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp20-%E5%92%8Chttp30%E5%8C%BA%E5%88%ABhttp30%E7%9A%84%E4%BC%98%E7%82%B9http20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">19.</span> <span class="toc-text">Q：HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 区别？（HTTP&#x2F;3.0 的优点，HTTP&#x2F;2.0 的缺点）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E4%BD%95%E5%AF%B9http11%E4%BC%98%E5%8C%96"><span class="toc-number">20.</span> <span class="toc-text">Q：如何对 HTTP&#x2F;1.1 优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttps%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E5%AF%86%E7%9A%84"><span class="toc-number">21.</span> <span class="toc-text">Q：HTTPS 是怎么加密的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%9A%E4%BF%A1%E5%89%8D%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%8F%AA%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%A1%8C%E4%B8%8D%E8%A1%8C"><span class="toc-number">22.</span> <span class="toc-text">Q：为什么通信前用非对称加密？（只用非对称加密行不行？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%AD%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8B%BF%E5%88%B0%E7%9A%84%E6%98%AF%E5%85%AC%E9%92%A5%E8%BF%98%E6%98%AF%E7%A7%81%E9%92%A5"><span class="toc-number">23.</span> <span class="toc-text">Q：非对称加密中，客户端拿到的是公钥还是私钥？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttps%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E8%A2%AB%E7%AF%A1%E6%94%B9"><span class="toc-number">24.</span> <span class="toc-text">Q：HTTPS 如何防止数据被篡改？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">25.</span> <span class="toc-text">Q：非对称加密的两种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%85%AC%E9%92%A5%E4%B9%9F%E8%A2%AB%E6%9B%BF%E6%8D%A2%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">26.</span> <span class="toc-text">Q：数字证书的作用？（公钥也被替换怎么办？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttps-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%85%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">27.</span> <span class="toc-text">Q：HTTPS 是如何建立连接的？其间交互了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp%E8%BF%9B%E8%A1%8Ctcp%E8%BF%9E%E6%8E%A5%E4%B9%8B%E5%90%8E%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%B8%AD%E6%96%AD"><span class="toc-number">28.</span> <span class="toc-text">Q：HTTP 进行 TCP 连接之后，在什么情况下会中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtsl%E6%8F%A1%E6%89%8B%E9%87%8C%E9%9D%A2%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88"><span class="toc-number">29.</span> <span class="toc-text">Q：TSL 握手里面的哈希函数用来干什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtsl%E6%8F%A1%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E5%AF%B9%E6%96%B9%E7%9A%84%E8%BA%AB%E4%BB%BD"><span class="toc-number">30.</span> <span class="toc-text">Q：TSL 握手的过程中怎么确定对方的身份</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qrsa%E7%AE%97%E6%B3%95%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">31.</span> <span class="toc-text">Q：RSA 算法的缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qrsa-%E5%92%8C-ecdhe-%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">32.</span> <span class="toc-text">Q：RSA 和 ECDHE 握手过程的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%A1%E9%AA%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">33.</span> <span class="toc-text">Q：客户端校验数字证书的流程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E8%AF%81%E4%B9%A6%E4%BF%A1%E4%BB%BB%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89"><span class="toc-number">34.</span> <span class="toc-text">Q：证书信任链是什么？为什么要有？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qocsp%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">35.</span> <span class="toc-text">Q：OCSP 的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%9A%E8%AF%9D%E5%A4%8D%E7%94%A8"><span class="toc-number">36.</span> <span class="toc-text">Q：什么是会话复用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttps-%E7%9A%84%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84"><span class="toc-number">37.</span> <span class="toc-text">Q：HTTPS 的应用数据是如何保证完整性的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttps-%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E5%90%97"><span class="toc-number">38.</span> <span class="toc-text">Q：HTTPS 一定安全可靠吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E8%83%BD%E6%88%AA%E5%8F%96-https-%E6%95%B0%E6%8D%AE"><span class="toc-number">39.</span> <span class="toc-text">Q：为什么抓包工具能截取 HTTPS 数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%A2%AB%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%8A%93%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">40.</span> <span class="toc-text">Q：如何避免被中间人抓取数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttps%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96"><span class="toc-number">41.</span> <span class="toc-text">Q：HTTPS 怎么优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E8%AF%A5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2"><span class="toc-number">42.</span> <span class="toc-text">Q：HTTP 是无状态的，该怎么解决呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%90%BA%E5%B8%A6cookie%E7%9A%84http%E8%AF%B7%E6%B1%82%E6%98%AF%E6%9C%89%E7%8A%B6%E6%80%81%E8%BF%98%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84cookie%E6%98%AFhttp%E5%8D%8F%E8%AE%AE%E7%B0%87%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%AF%B4http%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84"><span class="toc-number">43.</span> <span class="toc-text">Q：携带 Cookie 的 HTTP 请求是有状态还是无状态的？Cookie 是 HTTP 协议簇的一部分，那为什么还说 HTTP 是无状态的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qjwt%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">44.</span> <span class="toc-text">Q：jwt 的缺点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qurl%E5%92%8Curi%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">45.</span> <span class="toc-text">Q：URL 和 URI 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qcookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">46.</span> <span class="toc-text">Q：cookie 和 session 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E6%9E%9C%E6%88%91%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0-localstorage%E5%92%8Ccookie%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">47.</span> <span class="toc-text">Q：如果我把数据存储到 localStorage，和 Cookie 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qcookie%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A3%8E%E9%99%A9"><span class="toc-number">48.</span> <span class="toc-text">Q：cookie 有哪些风险？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qcookie%E6%94%AF%E6%8C%81%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E5%90%97"><span class="toc-number">49.</span> <span class="toc-text">Q：cookie 支持跨域访问吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qget%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">50.</span> <span class="toc-text">Q：GET 和 POST 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qget-%E8%AF%B7%E6%B1%82%E5%8F%AF%E4%BB%A5%E5%B8%A6-body-%E5%90%97"><span class="toc-number">51.</span> <span class="toc-text">Q：GET 请求可以带 body 吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qwebsocket%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89websocket"><span class="toc-number">52.</span> <span class="toc-text">Q：webSocket 是什么？为什么还要有 webSocket?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E7%AE%80%E8%BF%B0-cors-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">53.</span> <span class="toc-text">Q：简述 CORS 的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qwebsocket%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD"><span class="toc-number">54.</span> <span class="toc-text">Q：websocket 如何验证身份？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qping%E5%91%BD%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">55.</span> <span class="toc-text">Q：PING 命令是什么？工作原理又是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qdns%E6%98%AF%E4%BB%80%E4%B9%88%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">56.</span> <span class="toc-text">Q：DNS 是什么？解析过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qdns%E5%9F%BA%E4%BA%8Etcp%E8%BF%98%E6%98%AFudp%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">57.</span> <span class="toc-text">Q：DNS 基于 TCP 还是 UDP？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qdns%E5%8A%AB%E6%8C%81%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">58.</span> <span class="toc-text">Q：DNS 劫持是什么？怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">59.</span> <span class="toc-text">Q：TCP 头部字段有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qudp%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">60.</span> <span class="toc-text">Q：UDP 头部字段有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89tcp%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82"><span class="toc-number">61.</span> <span class="toc-text">Q：为什么要有 TCP? 工作在哪一层？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q-%E4%BB%80%E4%B9%88%E6%98%AFtcp%E8%BF%9E%E6%8E%A5"><span class="toc-number">62.</span> <span class="toc-text">Q : 什么是 TCP 连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%9C%89%E4%B8%80%E4%B8%AA-ip-%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9B%91%E5%90%AC%E4%BA%86%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%AE%83%E7%9A%84-tcp-%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">63.</span> <span class="toc-text">Q：有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qudp%E5%92%8Ctcp%E5%8C%BA%E5%88%AB"><span class="toc-number">64.</span> <span class="toc-text">Q：UDP 和 TCP 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qudp%E5%92%8Ctcp%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">65.</span> <span class="toc-text">Q：UDP 和 TCP 应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88-udp-%E5%A4%B4%E9%83%A8%E6%B2%A1%E6%9C%89%E9%A6%96%E9%83%A8%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E8%80%8C-tcp-%E5%A4%B4%E9%83%A8%E6%9C%89%E9%A6%96%E9%83%A8%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E5%91%A2"><span class="toc-number">66.</span> <span class="toc-text">Q：为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88-udp-%E5%A4%B4%E9%83%A8%E6%9C%89%E5%8C%85%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E8%80%8C-tcp-%E5%A4%B4%E9%83%A8%E5%88%99%E6%B2%A1%E6%9C%89%E5%8C%85%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E5%91%A2"><span class="toc-number">67.</span> <span class="toc-text">Q：为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="toc-number">68.</span> <span class="toc-text">Q：TCP 和 UDP 可以使用同一个端口吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A4%9A%E4%B8%AA-tcp-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="toc-number">69.</span> <span class="toc-text">Q：多个 TCP 服务进程可以绑定同一个端口吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E9%87%8D%E5%90%AF-tcp-%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89address-in-use%E7%9A%84%E6%8A%A5%E9%94%99%E4%BF%A1%E6%81%AF%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D"><span class="toc-number">70.</span> <span class="toc-text">Q：重启 TCP 服务进程时，为什么会有 “Address in use” 的报错信息？怎么避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5-bind-%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97"><span class="toc-number">71.</span> <span class="toc-text">Q : 客户端可以用同一个端口吗？多个客户端可以 bind 同一个端口吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%AE%A2%E6%88%B7%E7%AB%AF-tcp-%E8%BF%9E%E6%8E%A5-time_wait-%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%AB%AF%E5%8F%A3%E8%B5%84%E6%BA%90%E8%80%97%E5%B0%BD%E8%80%8C%E6%97%A0%E6%B3%95%E5%BB%BA%E7%AB%8B%E6%96%B0%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%90%97"><span class="toc-number">72.</span> <span class="toc-text">Q：客户端 TCP 连接 TIME_WAIT 状态过多，会导致端口资源耗尽而无法建立新的连接吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AB%AF%E5%8F%A3%E9%80%89%E6%8B%A9%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">73.</span> <span class="toc-text">Q：客户端端口选择的过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%BD%BF%E7%94%A8tcp%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8udp%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">74.</span> <span class="toc-text">Q：使用 TCP 的协议有哪些？使用 UDP 的协议有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">75.</span> <span class="toc-text">Q：TCP 三次握手过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%88%96%E8%80%85%E5%9B%9B%E6%AC%A1"><span class="toc-number">76.</span> <span class="toc-text">Q：为什么是三次握手，而不是两次或者四次？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8Back-%E6%8A%A5%E6%96%87%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E4%BA%86%E8%80%8C%E8%A2%AB%E5%8A%A8%E6%96%B9%E6%AD%A4%E6%97%B6%E8%BF%98%E6%98%AF-syn_received-%E7%8A%B6%E6%80%81%E5%A6%82%E6%9E%9C-ack-%E4%B8%A2%E4%BA%86%E9%82%A3%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B9%9F%E7%99%BD%E7%99%BD%E6%B5%AA%E8%B4%B9%E4%BA%86"><span class="toc-number">77.</span> <span class="toc-text">Q：客户端发送三次握手（ack 报文）后就可以发送数据了，而被动方此时还是 syn_received 状态，如果 ack 丢了，那客户端发的数据是不是也白白浪费了？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E8%A6%81%E6%B1%82%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%91%A2"><span class="toc-number">78.</span> <span class="toc-text">Q：为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7-isn-%E6%98%AF%E5%A6%82%E4%BD%95%E9%9A%8F%E6%9C%BA%E4%BA%A7%E7%94%9F%E7%9A%84"><span class="toc-number">79.</span> <span class="toc-text">Q：初始序列号 ISN 是如何随机产生的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E6%98%AF%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%83%BD%E9%81%BF%E5%85%8D%E8%BF%9E%E6%8E%A5%E6%8E%A5%E6%94%B6%E5%8E%86%E5%8F%B2%E6%8A%A5%E6%96%87%E5%90%97"><span class="toc-number">80.</span> <span class="toc-text">Q：客户端和服务端初始化序列号都是随机生成的话，就一定能避免连接接收历史报文吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%97%A2%E7%84%B6ip%E5%B1%82%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%88%86%E7%89%87%E4%B8%BA%E4%BB%80%E4%B9%88tcp%E5%B1%82%E8%BF%98%E9%9C%80%E8%A6%81mss"><span class="toc-number">81.</span> <span class="toc-text">Q：既然 IP 层会进行分片，为什么 TCP 层还需要 MSS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E6%80%8E%E6%A0%B7%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E6%80%8E%E6%A0%B7%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">82.</span> <span class="toc-text">Q：第一次挥手丢失会怎样？第二次挥手丢失会怎样？第三次挥手丢失会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%BB%80%E4%B9%88%E6%98%AFsyn%E6%94%BB%E5%87%BB%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">83.</span> <span class="toc-text">Q：什么是 SYN 攻击？如何避免？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">84.</span> <span class="toc-text">Q：TCP 四次挥手过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">85.</span> <span class="toc-text">Q：为什么是四次握手？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E7%AC%AC%E4%B8%80%E6%AC%A1-%E4%BA%8C%E6%AC%A1-%E4%B8%89%E6%AC%A1-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">86.</span> <span class="toc-text">Q：第一次、二次、三次、四次挥手丢失会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88time_wait%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF2msl"><span class="toc-number">87.</span> <span class="toc-text">Q：为什么 time_wait 的时间是 2MSL?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81time_wait%E7%8A%B6%E6%80%81"><span class="toc-number">88.</span> <span class="toc-text">Q：为什么需要 time_wait 状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtime_wait%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">89.</span> <span class="toc-text">Q：time_wait 状态过多的危害？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96time_wait"><span class="toc-number">90.</span> <span class="toc-text">Q：如何优化 time_wait?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-time_wait-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">91.</span> <span class="toc-text">Q：服务器出现大量 TIME_WAIT 状态的原因有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8Fclose_wait%E7%8A%B6%E6%80%81"><span class="toc-number">92.</span> <span class="toc-text">Q ：服务器出现大量 close_wait 状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%AF%E9%9D%A0"><span class="toc-number">93.</span> <span class="toc-text">Q：TCP 如何保证数据的可靠？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE"><span class="toc-number">94.</span> <span class="toc-text">Q：超时时间怎么设置？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">95.</span> <span class="toc-text">Q：糊涂窗口综合症是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qip%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">96.</span> <span class="toc-text">Q：IP 协议是什么？作用是什么？怎么工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%BD%A0%E7%9F%A5%E9%81%93ip%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4%E5%90%97"><span class="toc-number">97.</span> <span class="toc-text">Q：你知道 IP 地址过滤吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qipv4%E5%92%8Cipv6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">98.</span> <span class="toc-text">Q：IPv4 和 IPv6 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qnat%E7%9A%84%E4%BD%9C%E7%94%A8%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C"><span class="toc-number">99.</span> <span class="toc-text">Q：NAT 的作用？怎么工作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%BB%80%E4%B9%88%E6%98%AFarp%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">100.</span> <span class="toc-text">Q：什么是 ARP? 有什么作用？怎么工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qip%E6%AC%BA%E9%AA%97%E6%98%AF%E4%BB%80%E4%B9%88%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">101.</span> <span class="toc-text">Q：IP 欺骗是什么？怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qsql%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">102.</span> <span class="toc-text">Q：SQL 注入是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qudp-flood%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">103.</span> <span class="toc-text">Q：UDP Flood 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qhttp-flood%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">104.</span> <span class="toc-text">Q：HTTP Flood 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qdns-flood%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">105.</span> <span class="toc-text">Q：DNS Flood 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp%E9%87%8D%E7%BD%AE%E6%94%BB%E5%87%BB"><span class="toc-number">106.</span> <span class="toc-text">Q：TCP 重置攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qddos%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">107.</span> <span class="toc-text">Q：DDOS 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">108.</span> <span class="toc-text">Q：中间人攻击是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E6%9E%9C%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%AE%95%E6%9C%BA%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">109.</span> <span class="toc-text">Q：如果建立了连接，客户端突然宕机怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">110.</span> <span class="toc-text">Q：如果已经建立了连接，但是服务端的进程崩溃会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E9%92%88%E5%AF%B9tcp%E7%9A%84socket%E7%BC%96%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">111.</span> <span class="toc-text">Q：针对 TCP 的 Socket 编程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qlisten-%E6%97%B6%E5%80%99%E5%8F%82%E6%95%B0-backlog-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">112.</span> <span class="toc-text">Q：listen 时候参数 backlog 的意义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qaccept-%E5%8F%91%E7%94%9F%E5%9C%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%93%AA%E4%B8%80%E6%AD%A5"><span class="toc-number">113.</span> <span class="toc-text">Q：accept 发生在三次握手的哪一步？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8-close-%E4%BA%86%E8%BF%9E%E6%8E%A5%E6%98%AF%E6%96%AD%E5%BC%80%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">114.</span> <span class="toc-text">Q：客户端调用 close 了，连接是断开的流程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96tcp"><span class="toc-number">115.</span> <span class="toc-text">Q：如何优化 TCP?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3tcp%E6%98%AF%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84"><span class="toc-number">116.</span> <span class="toc-text">Q：如何理解 TCP 是面向字节流的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">117.</span> <span class="toc-text">Q：粘包问题是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qsyn%E6%8A%A5%E6%96%87%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A2%AB%E4%B8%A2%E5%BC%83"><span class="toc-number">118.</span> <span class="toc-text">Q：SYN 报文什么时候会被丢弃？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%B7%B2%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84tcp%E6%94%B6%E5%88%B0syn%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">119.</span> <span class="toc-text">Q：已建立连接的 TCP，收到 SYN 会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E4%B8%80%E4%B8%AAtcp%E8%BF%9E%E6%8E%A5"><span class="toc-number">120.</span> <span class="toc-text">Q：如何关闭一个 TCP 连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%9C%A8%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%92%8C%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B9%8B%E9%97%B4%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%94%B1%E4%BA%8E%E7%BD%91%E7%BB%9C%E9%98%BB%E5%A1%9E%E5%BB%B6%E8%BF%9F%E4%BA%86%E5%AF%BC%E8%87%B4%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84fin%E5%85%88%E5%88%B0%E8%BE%BE"><span class="toc-number">121.</span> <span class="toc-text">Q：在第二次挥手和第三次挥手之间，发送的数据由于网络阻塞延迟了，导致第三次握手的 FIN 先到达？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A4%84%E4%BA%8Etime_wait%E7%8A%B6%E6%80%81%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B6%E5%88%B0syn%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="toc-number">122.</span> <span class="toc-text">Q：处于 time_wait 状态的服务器，收到 SYN 会怎么样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%9C%A8-time_wait-%E7%8A%B6%E6%80%81%E6%94%B6%E5%88%B0-rst-%E4%BC%9A%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%90%97"><span class="toc-number">123.</span> <span class="toc-text">Q：在 TIME_WAIT 状态，收到 RST 会断开连接吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp%E8%BF%9E%E6%8E%A5%E4%B8%80%E7%AB%AF%E6%96%AD%E7%94%B5%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">124.</span> <span class="toc-text">Q：TCP 连接，一端断电和进程崩溃有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%8B%94%E6%8E%89%E7%BD%91%E7%BA%BF%E5%90%8E-%E5%8E%9F%E6%9C%AC%E7%9A%84-tcp-%E8%BF%9E%E6%8E%A5%E8%BF%98%E5%AD%98%E5%9C%A8%E5%90%97"><span class="toc-number">125.</span> <span class="toc-text">Q：拔掉网线后， 原本的 TCP 连接还存在吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88-tcp_tw_reuse-%E9%BB%98%E8%AE%A4%E6%98%AF%E5%85%B3%E9%97%AD%E7%9A%84"><span class="toc-number">126.</span> <span class="toc-text">Q：为什么 tcp_tw_reuse 默认是关闭的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q-https-%E4%B8%AD-tls-%E5%92%8C-tcp-%E8%83%BD%E5%90%8C%E6%97%B6%E6%8F%A1%E6%89%8B%E5%90%97"><span class="toc-number">127.</span> <span class="toc-text">Q： HTTPS 中 TLS 和 TCP 能同时握手吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp-keepalive-%E5%92%8C-http-keep-alive-%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%9C%E8%A5%BF%E5%90%97"><span class="toc-number">128.</span> <span class="toc-text">Q：TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qtcp%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%BA%E7%82%B9"><span class="toc-number">129.</span> <span class="toc-text">Q：TCP 有哪些缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-udp-%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">130.</span> <span class="toc-text">Q：如何基于 UDP 协议实现可靠传输？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B2%A1%E6%9C%89-listen%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">131.</span> <span class="toc-text">Q：服务端没有 listen，客户端发起连接建立，会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%B2%A1%E6%9C%89-listen%E8%83%BD%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E5%90%97"><span class="toc-number">132.</span> <span class="toc-text">Q：没有 listen，能建立 TCP 连接吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%98%AF%E4%B8%AA%E9%93%BE%E8%A1%A8%E8%80%8C%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%98%AF%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">133.</span> <span class="toc-text">Q：为什么全连接队列是个链表，而半连接队列是个哈希表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%B2%A1%E6%9C%89accept%E8%83%BD%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%90%97"><span class="toc-number">134.</span> <span class="toc-text">Q：没有 accept 能建立连接吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qsyn-cookies%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%8F%96%E4%BB%A3%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">135.</span> <span class="toc-text">Q：syn cookies 为什么不直接取代半连接队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E6%B6%88%E6%81%AF%E4%BB%8E%E8%81%8A%E5%A4%A9%E6%A1%86%E5%8F%91%E5%87%BA%E5%88%B0%E5%AF%B9%E6%96%B9%E6%94%B6%E5%88%B0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E8%BE%93%E7%9A%84"><span class="toc-number">136.</span> <span class="toc-text">Q：消息从聊天框发出到对方收到，是怎么传输的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%BC%9A%E4%B8%A2%E5%8C%85"><span class="toc-number">137.</span> <span class="toc-text">Q：什么场景会丢包？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E4%B8%A2%E5%8C%85%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">138.</span> <span class="toc-text">Q：丢包了怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q%E7%94%A8%E4%BA%86tcp%E5%8D%8F%E8%AE%AE%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%8C%85%E5%90%97"><span class="toc-number">139.</span> <span class="toc-text">Q：用了 TCP 协议就一定不会丢包吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qclose%E5%92%8Cshutdown%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">140.</span> <span class="toc-text">Q：close 和 shutdown 的区别？</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/cs/job/Bagu/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="bookmark" title="计算机网络">计算机网络</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Wu Zhian" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Wu Zhian</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">2</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">1</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/cs/job/Bagu/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="黑马点评常见问题">黑马点评常见问题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cs/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/cs/job/" title="分类于 找工作">找工作</a> <i class="ic i-angle-right"></i> <a href="/categories/cs/job/Bagu/" title="分类于 八股文">八股文</a></div><span><a href="/cs/job/Bagu/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Wu Zhian @ Zhian's Blog</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"cs/job/Bagu/计算机网络/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->